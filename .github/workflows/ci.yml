name: CI

concurrency:
  group: ci-${{ vars.PROJECT_KEY }}-${{ github.repository }}
  cancel-in-progress: true

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual CI trigger'
        required: false
        default: 'Manual testing'
        type: string
      force_app_version:
        description: 'Force application version creation (override commit filter)'
        required: false
        default: true
        type: boolean

jobs:
  analyze-commit:
    name: "Demo: Analyze Commit (Demo-Optimized)"
    runs-on: ubuntu-latest
    outputs:
      create_app_version: ${{ steps.demo-filter.outputs.create_version }}
      decision_reason: ${{ steps.demo-filter.outputs.reason }}
      commit_type: ${{ steps.demo-filter.outputs.commit_type }}
      core_changed: ${{ steps.detect-changes.outputs.core_changed }}
      devops_changed: ${{ steps.detect-changes.outputs.devops_changed }}
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2
          
      - name: "[Detection] Library Changes"
        id: detect-changes
        run: |
          CHANGED_FILES=$(git diff --name-only HEAD~1 2>/dev/null || echo "")
          
          if echo "$CHANGED_FILES" | grep -q "^libraries/bookverse-core/"; then
            echo "core_changed=true" >> $GITHUB_OUTPUT
            echo "üìö bookverse-core library changed"
          else
            echo "core_changed=false" >> $GITHUB_OUTPUT
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^libraries/bookverse-devops/"; then
            echo "devops_changed=true" >> $GITHUB_OUTPUT
            echo "üõ†Ô∏è bookverse-devops library changed"
          else
            echo "devops_changed=false" >> $GITHUB_OUTPUT
          fi
          
      - name: "[Demo] Commit Analysis (Optimized for Visibility)"
        id: demo-filter
        env:
          GITHUB_EVENT_INPUTS_FORCE_APP_VERSION: ${{ inputs.force_app_version }}
        run: |
          
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]] && [[ "${{ inputs.force_app_version }}" == "true" ]]; then
            echo "create_version=true" >> $GITHUB_OUTPUT
            echo "reason=Manual trigger with force_app_version=true" >> $GITHUB_OUTPUT
            echo "commit_type=manual-override" >> $GITHUB_OUTPUT
            echo "‚úÖ Demo: Forced application version creation (manual override)"
            exit 0
          fi
          
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            COMMIT_MSG="${{ github.event.pull_request.title }}"
            COMMIT_SHA="${{ github.event.pull_request.head.sha }}"
          else
            COMMIT_MSG="${{ github.event.head_commit.message }}"
            COMMIT_SHA="${{ github.sha }}"
          fi
          
          CHANGED_FILES=$(git diff --name-only HEAD~1 2>/dev/null || echo "")
          
          echo "üéØ DEMO MODE: Analyzing commit for infrastructure CI/CD pipeline"
          echo "üìù Commit: ${COMMIT_SHA:0:8}"
          echo "üí¨ Message: $COMMIT_MSG"
          echo "üìÅ Changed files: $(echo "$CHANGED_FILES" | wc -l) files"
          echo "üèóÔ∏è Infrastructure note: Multi-library build with separate evidence"
          echo ""
          
          if [[ "$COMMIT_MSG" =~ \[skip-version\] ]]; then
            echo "create_version=false" >> $GITHUB_OUTPUT
            echo "reason=Explicit [skip-version] tag" >> $GITHUB_OUTPUT
            echo "commit_type=build-only" >> $GITHUB_OUTPUT
            echo "üî® Demo: Build info only (explicit skip)"
            
          elif [[ "$COMMIT_MSG" =~ ^docs?: ]] && [[ -n "$CHANGED_FILES" ]] && [[ $(echo "$CHANGED_FILES" | grep -v '\.md$\|^docs/\|^README' | wc -l) -eq 0 ]]; then
            echo "create_version=false" >> $GITHUB_OUTPUT  
            echo "reason=Documentation-only changes" >> $GITHUB_OUTPUT
            echo "commit_type=build-only" >> $GITHUB_OUTPUT
            echo "üî® Demo: Build info only (docs-only)"
            
          else
            echo "create_version=true" >> $GITHUB_OUTPUT
            echo "reason=Demo mode: showing full infrastructure CI/CD pipeline" >> $GITHUB_OUTPUT
            echo "commit_type=release-ready" >> $GITHUB_OUTPUT
            echo "‚úÖ Demo: Creating app version (infrastructure demo visibility mode)"
            echo "üìù Production note: Real systems would be more conservative here"
          fi

  authenticate:
    name: "Shared OIDC Authentication"
    needs: analyze-commit
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Setup] Checkout bookverse-infra for shared scripts"
        uses: actions/checkout@v4
        with:
          repository: yonatanp-jfrog/bookverse-infra
          path: bookverse-infra

      - name: "[Setup] JFrog CLI"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        with:
          version: latest
          oidc-provider-name: bookverse-infra-github
          oidc-audience: ${{ vars.JFROG_URL }}
          disable-job-summary: true
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}

  build-bookverse-core:
    name: "Build: bookverse-core (Always Runs)"
    needs: [analyze-commit, authenticate]
    runs-on: ubuntu-latest
    
    outputs:
      build_name: ${{ steps.set-build-info.outputs.build_name }}
      build_number: ${{ steps.set-build-info.outputs.build_number }}
      app_version: ${{ steps.determine-semver.outputs.app_version }}
      core_version: ${{ steps.determine-semver.outputs.core_version }}
      package_version: ${{ steps.set-version.outputs.package_version }}
      coverage_percent: ${{ steps.test-coverage.outputs.coverage_percent }}
    defaults:
      run:
        shell: bash
        working-directory: libraries/bookverse-core
    permissions:
      contents: read
      id-token: write

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Info] Build Information"
        run: |
          echo "üìö Building bookverse-core Python library"
          echo "üîÑ Event: ${{ github.event_name }}"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo "üïê Timestamp: $(date -u)"
          
      - name: "[Setup] Build Info"
        id: set-build-info
        run: |
          BUILD_NAME="bookverse-core_${{ github.workflow }}_${{ github.job }}"
          BUILD_NUMBER="${{ github.run_number }}-${{ github.run_attempt }}"
          echo "build_name=$BUILD_NAME" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "üè∑Ô∏è Build: $BUILD_NAME #$BUILD_NUMBER"

      - name: "[Setup] Install and Configure JFrog CLI"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ env.BUILD_NAME }}
          JFROG_CLI_BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          JFROG_CLI_BUILD_PROJECT: ${{ vars.PROJECT_KEY }}
        with:
          version: latest
          oidc-provider-name: bookverse-infra-github
          oidc-audience: ${{ vars.JFROG_URL }}
          disable-job-summary: false
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false

      - name: "[Setup] Verify JFrog CLI Configuration"
        run: |
          echo "üîß Verifying JFrog CLI configuration"
          echo "‚úÖ JFrog CLI installed and configured with OIDC authentication"
          echo "üè∑Ô∏è Build: $BUILD_NAME #$BUILD_NUMBER"
          
          jf rt ping

      - name: "[Setup] Python"
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: "[Build] Install dependencies"
        run: |
          python -m pip install --upgrade "pip<25"
          pip install build twine
          
          pip install -r requirements.txt
          
          pip install -e .[dev]
          echo "‚úÖ Installed bookverse-core dependencies"

      - name: "[Test] Run tests with coverage"
        id: test-coverage
        run: |
          set -euo pipefail
          
          pytest tests/ -v --cov=bookverse_core --cov-report=term-missing --cov-report=xml --cov-report=html
          
          COVERAGE_PERCENT=$(python -c "
          import xml.etree.ElementTree as ET
          tree = ET.parse('coverage.xml')
          root = tree.getroot()
          coverage = float(root.attrib['line-rate']) * 100
          print(f'{coverage:.1f}')
          ")
          
          echo "coverage_percent=$COVERAGE_PERCENT" >> $GITHUB_OUTPUT
          echo "COVERAGE_PERCENT=$COVERAGE_PERCENT" >> $GITHUB_ENV
          echo "‚úÖ Tests passed with $COVERAGE_PERCENT% coverage"

      - name: "[Auth] OIDC Token Exchange (bookverse-devops shared script)"
        id: exchange-oidc
        run: |
          echo "üîê Using bookverse-devops shared OIDC exchange script"
          ../bookverse-devops/scripts/exchange-oidc-token.sh \
            --service-name "infra" \
            --provider-name "bookverse-infra-github" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --docker-registry "${{ vars.DOCKER_REGISTRY }}" \
            --verbose
          echo "‚úÖ OIDC token exchange completed using shared bookverse-devops script"

      - name: "[Setup] Determine SemVer"
        id: determine-semver
        run: |
          set -euo pipefail
          APPLICATION_KEY="bookverse-infra"
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "‚ùå Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          echo "‚úÖ Using persisted JFrog access token for semver determination"
          echo "üìã Using shared semver logic from bookverse-infra"
          INFRA_SCRIPTS_PATH="../bookverse-devops/scripts"
          if [[ -f "$INFRA_SCRIPTS_PATH/determine-semver.sh" ]]; then
            cp "$INFRA_SCRIPTS_PATH/determine-semver.sh" .
            cp "$INFRA_SCRIPTS_PATH/semver_versioning.py" .
            chmod +x determine-semver.sh
            echo "‚úÖ Using shared semver scripts from bookverse-infra"
          else
            echo "‚ùå Shared semver scripts not found in bookverse-infra at $INFRA_SCRIPTS_PATH" >&2
            exit 1
          fi
          echo "üîç Calculating version for bookverse-core package..."
          SEMVER_OUTPUT=$(./determine-semver.sh \
            --application-key "$APPLICATION_KEY" \
            --version-map "../../config/version-map.yaml" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --jfrog-token "$JF_OIDC_TOKEN" \
            --project-key "${{ vars.PROJECT_KEY }}" \
            --packages "bookverse-core" \
            --verbose)
          JSON_LINE=$(echo "$SEMVER_OUTPUT" | grep '{"application_key"')
          APP_VERSION=$(echo "$JSON_LINE" | jq -r '.app_version')
          if [[ -z "$APP_VERSION" || "$APP_VERSION" == "null" ]]; then
            echo "‚ùå Failed to extract APP_VERSION from semver output" >&2
            echo "üìã Semver output: $SEMVER_OUTPUT" >&2
            exit 1
          fi
          echo "üìã Extracting package version from JSON output:"
          
          CORE_VERSION=$(echo "$JSON_LINE" | jq -r '.package_tags."bookverse-core" // empty')
          if [[ -z "$CORE_VERSION" ]]; then
            echo "‚ùå Failed to determine CORE_VERSION from semver script" >&2
            echo "üìã Available package_tags: $(echo "$JSON_LINE" | jq -r '.package_tags | keys[]')" >&2
            exit 1
          fi
          
          echo "üè∑Ô∏è Package Version: bookverse-core: $CORE_VERSION"
          echo "üè∑Ô∏è Application Version: $APP_VERSION"
          
          echo "CORE_VERSION=$CORE_VERSION" >> $GITHUB_ENV
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "core_version=$CORE_VERSION" >> $GITHUB_OUTPUT
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT

      - name: "[Setup] Update Package Version"
        run: |
          set -euo pipefail
          
          echo "üè∑Ô∏è Using computed version for bookverse-core: $CORE_VERSION"
          
          # Update version in pyproject.toml 
          if [[ -f "pyproject.toml" ]]; then
            # Use sed to replace the version line
            sed -i.bak "s/^version = .*/version = \"$CORE_VERSION\"/" pyproject.toml
            
            # Verify the change
            NEW_VERSION=$(grep '^version = ' pyproject.toml | sed 's/version = "\(.*\)"/\1/')
            if [[ "$NEW_VERSION" == "$CORE_VERSION" ]]; then
              echo "‚úÖ Updated pyproject.toml version to $CORE_VERSION"
            else
              echo "‚ùå Failed to update version in pyproject.toml" >&2
              echo "Expected: $CORE_VERSION, Found: $NEW_VERSION" >&2
              exit 1
            fi
          else
            echo "‚ùå pyproject.toml not found" >&2
            exit 1
          fi

      - name: "[Build] Package library"
        id: set-version
        run: |
          python -m build
          
          PACKAGE_VERSION=$(python -c "
          import configparser
          import os
          from pathlib import Path
          
          try:
              import tomllib
              with open('pyproject.toml', 'rb') as f:
                  data = tomllib.load(f)
              version = data['project']['version']
          except:
              version = '0.1.0'
          
          print(version)
          ")
          
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "PACKAGE_VERSION=$PACKAGE_VERSION" >> $GITHUB_ENV
          echo "‚úÖ Built bookverse-core v$PACKAGE_VERSION"

      - name: "[Artifacts] Upload to JFrog"
        run: |
          set -euo pipefail
          
          jf rt upload "dist/*.whl" "${{ vars.PROJECT_KEY }}-pypi-cache-local/" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" --project "${{ vars.PROJECT_KEY }}"
          jf rt upload "dist/*.tar.gz" "${{ vars.PROJECT_KEY }}-pypi-cache-local/" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" --project "${{ vars.PROJECT_KEY }}"
          
          echo "‚ÑπÔ∏è  Coverage upload temporarily disabled - repository not available"
          
          echo "‚úÖ Uploaded bookverse-core artifacts to JFrog"

      - name: "[Build] Publish Build Info"
        run: |
          set -euo pipefail
          
          echo "üìã Publishing build-info for bookverse-core library"
          echo "üèóÔ∏è Build: $BUILD_NAME/$BUILD_NUMBER"
          echo "üì¶ Contains: Python wheel + source distribution + test coverage"
          
          jf rt bag --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          jf rt bce --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          if BUILD_PUBLISH_RESULT=$(jf rt bp --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"); then
            echo "BUILD_INFO_PUBLISH_STATUS=SUCCESS" >> $GITHUB_ENV
            # More specific URL extraction for bookverse-core build  
            BUILD_UI_URL=$(echo "$BUILD_PUBLISH_RESULT" | grep -o "https://[^[:space:]]*builds/bookverse-core_CI_build-bookverse-core/[^[:space:]]*" | head -1 || echo "")
            
            if [[ -n "$BUILD_UI_URL" ]]; then
              EPOCH_MS=$(echo "$BUILD_UI_URL" | sed -n 's|.*/builds/[^/]*/[^/]*/\([0-9]*\)/published.*|\1|p')
              
              if [[ -n "$EPOCH_MS" && "$EPOCH_MS" =~ ^[0-9]+$ ]]; then
                EPOCH_SEC=$((EPOCH_MS / 1000))
                BUILD_TIME=$(date -d "@$EPOCH_SEC" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || date -r "$EPOCH_SEC" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || echo "Unknown")
                echo "BUILD_UI_URL=$BUILD_UI_URL" >> $GITHUB_ENV
                echo "BUILD_TIME=$BUILD_TIME" >> $GITHUB_ENV
              fi
            fi
            
            echo "‚úÖ Build info published successfully for bookverse-core"
            echo "üîó Build URL: ${BUILD_UI_URL:-'URL extraction failed'}"
          else
            echo "‚ùå Failed to publish build info for bookverse-core"
            exit 1
          fi

      - name: "[Evidence] Attach build evidence using shared library"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
          EVIDENCE_KEY_ALIAS: ${{ vars.EVIDENCE_KEY_ALIAS }}
        run: |
          set -euo pipefail
          
          echo "üìã Using shared evidence library for bookverse-core build"
          
          # Source the shared evidence library
          source ../bookverse-devops/scripts/evidence-lib.sh
          
          # Set environment variables for evidence library
          export SERVICE_NAME="core"
          export APPLICATION_KEY="bookverse-core"
          export PACKAGE_NAME="bookverse-core"
          export PACKAGE_VERSION="$PACKAGE_VERSION"
          export ATTACH_TO_BUILD="true"
          export ATTACH_TO_PACKAGE="false"
          
          # Attach build-level evidence using shared library
          echo "üèóÔ∏è Attaching SonarQube evidence to build"
          attach_build_sonar_evidence
          
          echo "üìã Attaching FOSSA license evidence to build"
          attach_build_fossa_evidence
          
          echo "‚úÖ Evidence attached to build using shared library"

  build-bookverse-devops:
    name: "Build: bookverse-devops (Always Runs)"  
    needs: [analyze-commit, authenticate]
    runs-on: ubuntu-latest
    
    outputs:
      build_name: ${{ steps.set-build-info.outputs.build_name }}
      build_number: ${{ steps.set-build-info.outputs.build_number }}
      app_version: ${{ steps.determine-semver.outputs.app_version }}
      devops_version: ${{ steps.determine-semver.outputs.devops_version }}
      package_version: ${{ steps.set-version.outputs.package_version }}
    defaults:
      run:
        shell: bash
        working-directory: libraries/bookverse-devops
    permissions:
      contents: read
      id-token: write

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Info] Build Information"
        run: |
          echo "üõ†Ô∏è Building bookverse-devops CI/CD library"
          echo "üîÑ Event: ${{ github.event_name }}"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo "üïê Timestamp: $(date -u)"
          
      - name: "[Setup] Build Info"
        id: set-build-info
        run: |
          BUILD_NAME="bookverse-devops_${{ github.workflow }}_${{ github.job }}"
          BUILD_NUMBER="${{ github.run_number }}-${{ github.run_attempt }}"
          echo "build_name=$BUILD_NAME" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "üè∑Ô∏è Build: $BUILD_NAME #$BUILD_NUMBER"

      - name: "[Setup] Install and Configure JFrog CLI"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ env.BUILD_NAME }}
          JFROG_CLI_BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          JFROG_CLI_BUILD_PROJECT: ${{ vars.PROJECT_KEY }}
        with:
          version: latest
          oidc-provider-name: bookverse-infra-github
          oidc-audience: ${{ vars.JFROG_URL }}
          disable-job-summary: false
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false

      - name: "[Setup] Verify JFrog CLI Configuration"
        run: |
          echo "üîß Verifying JFrog CLI configuration"
          echo "‚úÖ JFrog CLI installed and configured with OIDC authentication"
          echo "üè∑Ô∏è Build: $BUILD_NAME #$BUILD_NUMBER"
          
          jf rt ping

      - name: "[Setup] Python"
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: "[Build] Install dependencies"
        run: |
          python -m pip install --upgrade "pip<25"
          pip install requests urllib3 pyyaml
          echo "‚úÖ Installed bookverse-devops dependencies"

      - name: "[Test] Validate scripts and workflows"
        run: |
          set -euo pipefail
          
          python scripts/semver_versioning.py --help
          echo "‚úÖ semver_versioning.py script validated"
          
          chmod +x scripts/determine-semver.sh
          ./scripts/determine-semver.sh --help || echo "Script help test completed"
          echo "‚úÖ determine-semver.sh script validated"
          
          python -c "
          import yaml
          import os
          
          yaml_files = []
          for root, dirs, files in os.walk('.'):
              for file in files:
                  if file.endswith('.yml') or file.endswith('.yaml'):
                      yaml_files.append(os.path.join(root, file))
          
          for file in yaml_files:
              try:
                  with open(file, 'r') as f:
                      yaml.safe_load(f)
                  print(f'‚úÖ {file} is valid YAML')
              except Exception as e:
                  print(f'‚ùå {file} has invalid YAML: {e}')
                  exit(1)
          
          print('‚úÖ All YAML files validated')
          "

      - name: "[Auth] OIDC Token Exchange (bookverse-devops shared script)"
        id: exchange-oidc
        run: |
          echo "üîê Using bookverse-devops shared OIDC exchange script"
          scripts/exchange-oidc-token.sh \
            --service-name "infra" \
            --provider-name "bookverse-infra-github" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --docker-registry "${{ vars.DOCKER_REGISTRY }}" \
            --verbose
          echo "‚úÖ OIDC token exchange completed using shared bookverse-devops script"

      - name: "[Setup] Determine SemVer"
        id: determine-semver
        run: |
          set -euo pipefail
          APPLICATION_KEY="bookverse-infra"
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "‚ùå Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          echo "‚úÖ Using persisted JFrog access token for semver determination"
          echo "üìã Using shared semver logic from bookverse-infra"
          INFRA_SCRIPTS_PATH="scripts"
          if [[ -f "$INFRA_SCRIPTS_PATH/determine-semver.sh" ]]; then
            cp "$INFRA_SCRIPTS_PATH/determine-semver.sh" .
            cp "$INFRA_SCRIPTS_PATH/semver_versioning.py" .
            chmod +x determine-semver.sh
            echo "‚úÖ Using local semver scripts"
          else
            echo "‚ùå Shared semver scripts not found at $INFRA_SCRIPTS_PATH" >&2
            exit 1
          fi
          echo "üîç Calculating version for bookverse-devops package..."
          SEMVER_OUTPUT=$(./determine-semver.sh \
            --application-key "$APPLICATION_KEY" \
            --version-map "../../config/version-map.yaml" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --jfrog-token "$JF_OIDC_TOKEN" \
            --project-key "${{ vars.PROJECT_KEY }}" \
            --packages "bookverse-devops" \
            --verbose)
          JSON_LINE=$(echo "$SEMVER_OUTPUT" | grep '{"application_key"')
          APP_VERSION=$(echo "$JSON_LINE" | jq -r '.app_version')
          if [[ -z "$APP_VERSION" || "$APP_VERSION" == "null" ]]; then
            echo "‚ùå Failed to extract APP_VERSION from semver output" >&2
            echo "üìã Semver output: $SEMVER_OUTPUT" >&2
            exit 1
          fi
          echo "üìã Extracting package version from JSON output:"
          
          DEVOPS_VERSION=$(echo "$JSON_LINE" | jq -r '.package_tags."bookverse-devops" // empty')
          if [[ -z "$DEVOPS_VERSION" ]]; then
            echo "‚ùå Failed to determine DEVOPS_VERSION from semver script" >&2
            echo "üìã Available package_tags: $(echo "$JSON_LINE" | jq -r '.package_tags | keys[]')" >&2
            exit 1
          fi
          
          echo "üè∑Ô∏è Package Version: bookverse-devops: $DEVOPS_VERSION"
          echo "üè∑Ô∏è Application Version: $APP_VERSION"
          
          echo "DEVOPS_VERSION=$DEVOPS_VERSION" >> $GITHUB_ENV
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "devops_version=$DEVOPS_VERSION" >> $GITHUB_OUTPUT
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT

      - name: "[Build] Package DevOps artifacts"
        id: set-version
        run: |
          PACKAGE_VERSION="$DEVOPS_VERSION"
          echo "üè∑Ô∏è Using computed version for bookverse-devops: $PACKAGE_VERSION"
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "PACKAGE_VERSION=$PACKAGE_VERSION" >> $GITHUB_ENV
          
          tar -czf "bookverse-devops-${PACKAGE_VERSION}.tar.gz" scripts/ evidence/ templates/ *.md
          
          cat > version-manifest.json << EOF
          {
            "name": "bookverse-devops",
            "version": "$PACKAGE_VERSION",
            "build_number": "$BUILD_NUMBER",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "contents": {
              "scripts": "$(ls scripts/ | wc -l) files",
              "evidence_templates": "$(find evidence/ -name '*.template' | wc -l) templates",
              "workflow_templates": "$(find templates/ -name '*.yml' -o -name '*.yaml' | wc -l) workflows"
            }
          }
          EOF
          
          echo "‚úÖ Packaged bookverse-devops v$PACKAGE_VERSION"

      - name: "[Debug] Repository Access Test"
        run: |
          set -euo pipefail
          
          echo "üîç DEBUG: Testing repository access before upload"
          GENERIC_REPO="${{ vars.PROJECT_KEY }}-infra-internal-generic-nonprod-local"
          
          echo "üîó Target repository: $GENERIC_REPO"
          echo "üì¶ Artifact: bookverse-devops-${PACKAGE_VERSION}.tar.gz"
          
          # Test 1: Check if repository exists
          echo "üìã Test 1: Repository existence check"
          jf rt ping --url="${{ vars.JFROG_URL }}/artifactory/$GENERIC_REPO" || echo "‚ùå Repository ping failed"
          
          # Test 2: List repository contents (if any)
          echo "üìã Test 2: Repository contents"
          jf rt search "$GENERIC_REPO/*" --project "${{ vars.PROJECT_KEY }}" || echo "‚ÑπÔ∏è Repository empty or not accessible"
          
          # Test 3: Check specific path where we're trying to upload
          echo "üìã Test 3: Check target path"
          TARGET_PATH="$GENERIC_REPO/devops/$PACKAGE_VERSION/"
          jf rt search "$TARGET_PATH*" --project "${{ vars.PROJECT_KEY }}" || echo "‚ÑπÔ∏è Target path doesn't exist (expected for new version)"
          
          # Test 4: Try to get repository information
          echo "üìã Test 4: Repository info"
          curl -s -H "Authorization: Bearer $JF_OIDC_TOKEN" \
               "${{ vars.JFROG_URL }}/artifactory/api/repositories/$GENERIC_REPO" | jq '.' || echo "‚ùå Repository info failed"
          
          # Test 5: List all repositories to see what exists
          echo "üìã Test 5: List all repositories containing 'infra'"
          curl -s -H "Authorization: Bearer $JF_OIDC_TOKEN" \
               "${{ vars.JFROG_URL }}/artifactory/api/repositories" | jq '.[] | select(.key | contains("infra"))' || echo "‚ùå Repository list failed"

      - name: "[Artifacts] Upload to JFrog"
        run: |
          set -euo pipefail
          
          echo "üì¶ Uploading DevOps artifacts to JFrog"
          
          # Upload DevOps package and manifest to generic repository (TEMP: using pypi-cache while waiting for platform setup)
          GENERIC_REPO="${{ vars.PROJECT_KEY }}-pypi-cache-local"
          jf rt upload "bookverse-devops-${PACKAGE_VERSION}.tar.gz" "$GENERIC_REPO/devops/$PACKAGE_VERSION/bookverse-devops-${PACKAGE_VERSION}.tar.gz" \
            --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" --project "${{ vars.PROJECT_KEY }}"
          
          jf rt upload "version-manifest.json" "$GENERIC_REPO/devops/$PACKAGE_VERSION/version-manifest.json" \
            --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER" --project "${{ vars.PROJECT_KEY }}"
          
          echo "‚úÖ DevOps artifacts uploaded to JFrog"
          echo "üì¶ Uploaded: bookverse-devops-${PACKAGE_VERSION}.tar.gz, version-manifest.json"

      - name: "[Build] Publish Build Info"
        run: |
          set -euo pipefail
          
          echo "üìã Publishing build-info for bookverse-devops library"
          echo "üèóÔ∏è Build: $BUILD_NAME/$BUILD_NUMBER"
          echo "üì¶ Contains: DevOps scripts + templates + validation evidence"
          
          jf rt bag --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          jf rt bce --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          if BUILD_PUBLISH_RESULT=$(jf rt bp --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"); then
            echo "BUILD_INFO_PUBLISH_STATUS=SUCCESS" >> $GITHUB_ENV
            # More specific URL extraction for bookverse-devops build
            BUILD_UI_URL=$(echo "$BUILD_PUBLISH_RESULT" | grep -o "https://[^[:space:]]*builds/bookverse-devops_CI_build-bookverse-devops/[^[:space:]]*" | head -1 || echo "")
            
            if [[ -n "$BUILD_UI_URL" ]]; then
              EPOCH_MS=$(echo "$BUILD_UI_URL" | sed -n 's|.*/builds/[^/]*/[^/]*/\([0-9]*\)/published.*|\1|p')
              
              if [[ -n "$EPOCH_MS" && "$EPOCH_MS" =~ ^[0-9]+$ ]]; then
                EPOCH_SEC=$((EPOCH_MS / 1000))
                BUILD_TIME=$(date -d "@$EPOCH_SEC" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || date -r "$EPOCH_SEC" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || echo "Unknown")
                echo "BUILD_UI_URL=$BUILD_UI_URL" >> $GITHUB_ENV
                echo "BUILD_TIME=$BUILD_TIME" >> $GITHUB_ENV
              fi
            fi
            
            echo "‚úÖ Build info published successfully for bookverse-devops"
            echo "üîó Build URL: ${BUILD_UI_URL:-'URL extraction failed'}"
          else
            echo "‚ùå Failed to publish build info for bookverse-devops"
            exit 1
          fi

      - name: "[Evidence] Attach build evidence using shared library"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
          EVIDENCE_KEY_ALIAS: ${{ vars.EVIDENCE_KEY_ALIAS }}
        run: |
          set -euo pipefail
          
          echo "üìã Using shared evidence library for bookverse-devops build"
          
          # Source the shared evidence library
          source scripts/evidence-lib.sh
          
          # Set environment variables for evidence library
          export SERVICE_NAME="devops"
          export APPLICATION_KEY="bookverse-devops"
          export PACKAGE_NAME="bookverse-devops"
          export PACKAGE_VERSION="$PACKAGE_VERSION"
          export ATTACH_TO_BUILD="true"
          export ATTACH_TO_PACKAGE="false"
          
          # Attach build-level evidence for DevOps library
          echo "üèóÔ∏è Attaching SonarQube evidence to build"
          attach_build_sonar_evidence
          
          echo "üìã Attaching FOSSA license evidence to build"
          attach_build_fossa_evidence
          
          echo "‚úÖ Evidence attached to build using shared library"

  create-promote:
    name: "Create Application Version & Promote (Conditional)"
    needs: [analyze-commit, build-bookverse-core, build-bookverse-devops]
    if: needs.analyze-commit.outputs.create_app_version == 'true' && ((needs.build-bookverse-core.result == 'success' || needs.build-bookverse-devops.result == 'success') || (needs.build-bookverse-core.result == 'skipped' && needs.build-bookverse-devops.result == 'skipped'))
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    
    env:
      BUILD_NAME: "bookverse-infra_CI_create-promote"
      BUILD_NUMBER: ${{ github.run_number }}-${{ github.run_attempt }}
      SERVICE_NAME: "infra"
      APPLICATION_KEY: "bookverse-infra"
      EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
      EVIDENCE_KEY_ALIAS: ${{ vars.EVIDENCE_KEY_ALIAS }}
      JFROG_URL: ${{ vars.JFROG_URL }}
      JF_URL: ${{ vars.JFROG_URL }}
      PROJECT_KEY: ${{ vars.PROJECT_KEY }}
      STAGES_STR: "DEV QA STAGING PROD"
      FINAL_STAGE: "PROD"
      ALLOW_RELEASE: "true"
    
    outputs:
      app_version: ${{ steps.create-version.outputs.app_version }}
    
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Setup] Checkout bookverse-infra for shared scripts"
        uses: actions/checkout@v4
        with:
          repository: yonatanp-jfrog/bookverse-infra
          path: bookverse-infra

      - name: "[Setup] JFrog CLI"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        with:
          version: latest
          oidc-provider-name: bookverse-infra-github
          oidc-audience: ${{ vars.JFROG_URL }}
          disable-job-summary: true
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ env.BUILD_NAME }}
          JFROG_CLI_BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          JFROG_CLI_BUILD_PROJECT: ${{ vars.PROJECT_KEY }}

      - name: "[Auth] OIDC Token Exchange (bookverse-devops shared script)"
        id: exchange-oidc
        run: |
          echo "üîê Using bookverse-devops shared OIDC exchange script"
          bookverse-infra/libraries/bookverse-devops/scripts/exchange-oidc-token.sh \
            --service-name "infra" \
            --provider-name "bookverse-infra-github" \
            --jfrog-url "${{ vars.JFROG_URL }}" \
            --docker-registry "${{ vars.DOCKER_REGISTRY }}" \
            --verbose
          echo "‚úÖ OIDC token exchange completed using shared bookverse-devops script"

      - name: "[Setup] Install Python dependencies"
        run: |
          pip install --user PyYAML setuptools wheel
          echo "‚úÖ Python dependencies installed"

      - name: "[Setup] Use Computed Versions" 
        run: |
          # Get application version from either build job (they should be the same)
          APP_VERSION="${{ needs.build-bookverse-core.outputs.app_version || needs.build-bookverse-devops.outputs.app_version }}"
          CORE_VERSION="${{ needs.build-bookverse-core.outputs.core_version }}"
          DEVOPS_VERSION="${{ needs.build-bookverse-devops.outputs.devops_version }}"
          
          echo "üè∑Ô∏è Using computed versions from build jobs:"
          echo "   üè∑Ô∏è Application: $APP_VERSION"
          echo "   üì¶ bookverse-core: $CORE_VERSION"
          echo "   üõ†Ô∏è bookverse-devops: $DEVOPS_VERSION"
          
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV

      - name: "[Debug] Test JFrog and AppTrust Permissions"
        run: |
          echo "üîç DEBUG: Testing various JFrog and AppTrust operations to isolate permission issues"
          echo "üîê Using JF_OIDC_TOKEN for authentication"
          
          BASE="${{ vars.JFROG_URL }}/apptrust/api/v1"
          
          echo ""
          echo "üìã === BASIC CONNECTIVITY TESTS ==="
          echo "üîó Testing JFrog connectivity..."
          jf rt ping || echo "‚ùå JFrog ping failed"
          
          echo ""
          echo "üìã === BUILD INFO READ TESTS ==="
          echo "üîç Testing build info queries..."
          
          # Test reading build info for our current builds
          echo "üì¶ Querying bookverse-core build info..."
          jf rt build-info bookverse-core_CI_build-bookverse-core ${{ needs.build-bookverse-core.outputs.build_number }} --project "${{ vars.PROJECT_KEY }}" || echo "‚ùå Failed to read core build info"
          
          echo "üì¶ Querying bookverse-devops build info..."
          jf rt build-info bookverse-devops_CI_build-bookverse-devops ${{ needs.build-bookverse-devops.outputs.build_number }} --project "${{ vars.PROJECT_KEY }}" || echo "‚ùå Failed to read devops build info"
          
          echo ""
          echo "üìã === APPTRUST API READ TESTS ==="
          echo "üîç Testing AppTrust API read operations..."
          
          # Test getting applications
          echo "üì± Getting applications..."
          curl -s -H "Authorization: Bearer $JF_OIDC_TOKEN" \
               -H "Content-Type: application/json" \
               "$BASE/applications" | jq '.' || echo "‚ùå Failed to get applications"
          
          # Test getting packages (if any exist)
          echo "üì¶ Getting packages..."
          curl -s -H "Authorization: Bearer $JF_OIDC_TOKEN" \
               -H "Content-Type: application/json" \
               "$BASE/packages" | jq '.' || echo "‚ùå Failed to get packages"
          
          # Test getting specific application (if exists)
          APP_KEY="${{ vars.APPLICATION_KEY }}"
          echo "üì± Getting application: $APP_KEY..."
          curl -s -H "Authorization: Bearer $JF_OIDC_TOKEN" \
               -H "Content-Type: application/json" \
               "$BASE/applications/$APP_KEY" | jq '.' || echo "‚ùå Failed to get specific application (expected if doesn't exist)"
          
          # Test getting application versions for a known application
          echo "üìã Getting application versions for $APP_KEY..."
          curl -s -H "Authorization: Bearer $JF_OIDC_TOKEN" \
               -H "Content-Type: application/json" \
               "$BASE/applications/$APP_KEY/versions" | jq '.' || echo "‚ùå Failed to get application versions (expected if app doesn't exist)"
          
          echo ""
          echo "üìã === APPTRUST API WRITE TESTS (NON-DESTRUCTIVE) ==="
          echo "üîç Testing AppTrust API write operations on existing data..."
          
          # Try to get a list of existing applications and test tagging on one
          echo "üì± Looking for existing applications to test tag modification..."
          EXISTING_APPS=$(curl -s -H "Authorization: Bearer $JF_OIDC_TOKEN" \
                              -H "Content-Type: application/json" \
                              "$BASE/applications" | jq -r '.applications[]?.application_key // empty' 2>/dev/null | head -3)
          
          if [[ -n "$EXISTING_APPS" ]]; then
            for app in $EXISTING_APPS; do
              echo "üè∑Ô∏è Testing tag operations on existing app: $app"
              
              # Get versions for this app
              VERSIONS=$(curl -s -H "Authorization: Bearer $JF_OIDC_TOKEN" \
                             -H "Content-Type: application/json" \
                             "$BASE/applications/$app/versions" | jq -r '.versions[]?.version // empty' 2>/dev/null | head -1)
              
              if [[ -n "$VERSIONS" ]]; then
                VERSION=$(echo "$VERSIONS" | head -1)
                echo "üìã Testing tag modification on $app@$VERSION..."
                
                # Get current tags
                echo "üìã Current tags for $app@$VERSION:"
                curl -s -H "Authorization: Bearer $JF_OIDC_TOKEN" \
                     -H "Content-Type: application/json" \
                     "$BASE/applications/$app/versions/$VERSION" | jq '.tag // "no-tag"' || echo "‚ùå Failed to get version details"
                
                # Try to update tag (non-destructive test)
                echo "üè∑Ô∏è Testing tag update (adding 'debug-test' tag)..."
                curl -s -w "HTTP_%{http_code}" -H "Authorization: Bearer $JF_OIDC_TOKEN" \
                     -H "Content-Type: application/json" \
                     -X PATCH \
                     -d '{"tag": "debug-test"}' \
                     "$BASE/applications/$app/versions/$VERSION" || echo "‚ùå Failed to update tag"
                
                break # Only test one version
              else
                echo "‚ÑπÔ∏è No versions found for app: $app"
              fi
            done
          else
            echo "‚ÑπÔ∏è No existing applications found to test tag operations"
          fi
          
          echo ""
          echo "üìã === REPOSITORY ACCESS TESTS ==="
          echo "üîç Testing repository access patterns..."
          
          # Test artifact search in known repositories
          echo "üì¶ Testing pypi repository access..."
          jf rt search "${{ vars.PROJECT_KEY }}-pypi-cache-local/*" --project "${{ vars.PROJECT_KEY }}" || echo "‚ùå Failed to search pypi repository"
          
          echo "üì¶ Testing generic repository access..."
          jf rt search "${{ vars.PROJECT_KEY }}-infra-internal-generic-nonprod-local/*" --project "${{ vars.PROJECT_KEY }}" || echo "‚ùå Failed to search generic repository (expected if empty)"
          
          echo ""
          echo "üìã === DEBUG SUMMARY ==="
          echo "‚úÖ Debug tests completed - check outputs above for permission patterns"
          echo "üîê Token available: $([ -n "$JF_OIDC_TOKEN" ] && echo "YES" || echo "NO")"
          echo "üè∑Ô∏è Application Key: ${{ vars.APPLICATION_KEY }}"
          echo "üèóÔ∏è Project Key: ${{ vars.PROJECT_KEY }}"
          echo "üåê JFrog URL: ${{ vars.JFROG_URL }}"

      - name: "[Create] Application Version"
        run: |
          echo "üöÄ Creating AppTrust application version: ${{ env.APP_VERSION }}"
          echo "üì¶ Binding artifacts from dual infrastructure builds:"
          echo "   - bookverse-core: ${{ needs.build-bookverse-core.outputs.build_name }}/${{ needs.build-bookverse-core.outputs.build_number }}"
          echo "   - bookverse-devops: ${{ needs.build-bookverse-devops.outputs.build_name }}/${{ needs.build-bookverse-devops.outputs.build_number }}"
          echo "üîó This creates an immutable link between application version and all published artifacts"
          
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "‚ùå Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          echo "‚úÖ Using JF_OIDC_TOKEN for AppTrust API authentication"
          
          BASE="${{ vars.JFROG_URL }}/apptrust/api/v1"
          APP_KEY="${{ vars.APPLICATION_KEY }}"
          APP_VERSION="${{ env.APP_VERSION }}"
          
          TAG_OPTIONS=(release hotfix feature bugfix enhancement security performance refactor)
          TAG_INDEX=$((${GITHUB_RUN_NUMBER:-0} % ${#TAG_OPTIONS[@]}))
          APP_TAG="${TAG_OPTIONS[$TAG_INDEX]}"
          
          # Build sources array for dual builds - handle mixed scenarios
          SOURCES='[]'
          
          # Function to get latest build info from JFrog
          get_latest_build() {
            local build_name_pattern="$1"
            echo "üîç Searching for latest build: $build_name_pattern"
            
            # Use JFrog CLI to get latest build
            local latest_build
            latest_build=$(jf rt search "*" --build "$build_name_pattern" --limit 1 --sort-by created --sort-order desc 2>/dev/null | jq -r '.[0].build_name // empty' 2>/dev/null || echo "")
            
            if [[ -n "$latest_build" ]]; then
              # Extract build number from the latest build
              local build_number
              build_number=$(jf rt search "*" --build "$build_name_pattern" --limit 1 --sort-by created --sort-order desc 2>/dev/null | jq -r '.[0].build_number // empty' 2>/dev/null || echo "")
              echo "‚úÖ Found latest build: $latest_build#$build_number"
              echo "$latest_build#$build_number"
            else
              echo "‚ö†Ô∏è No previous builds found for: $build_name_pattern"
              echo ""
            fi
          }
          
          # Handle bookverse-core builds
          if [[ "${{ needs.build-bookverse-core.result }}" == "success" ]]; then
            echo "üì¶ Using current bookverse-core build: ${{ needs.build-bookverse-core.outputs.build_name }}/${{ needs.build-bookverse-core.outputs.build_number }}"
            CORE_SOURCE='{"name":"${{ needs.build-bookverse-core.outputs.build_name }}","number":"${{ needs.build-bookverse-core.outputs.build_number }}","repository_key":"${{ vars.PROJECT_KEY }}-build-info","include_dependencies":false}'
            SOURCES=$(echo "$SOURCES" | jq ". + [$CORE_SOURCE]")
          elif [[ "${{ needs.build-bookverse-devops.result }}" == "success" ]]; then
            # DevOps build succeeded but core was skipped - get latest core build
            echo "üîç bookverse-core build was skipped, finding latest existing build..."
            LATEST_CORE=$(get_latest_build "bookverse-core_CI_*")
            if [[ -n "$LATEST_CORE" && "$LATEST_CORE" != "" ]]; then
              CORE_BUILD_NAME="${LATEST_CORE%#*}"
              CORE_BUILD_NUMBER="${LATEST_CORE#*#}"
              echo "üì¶ Using latest bookverse-core build: $CORE_BUILD_NAME/$CORE_BUILD_NUMBER"
              CORE_SOURCE='{"name":"'$CORE_BUILD_NAME'","number":"'$CORE_BUILD_NUMBER'","repository_key":"${{ vars.PROJECT_KEY }}-build-info","include_dependencies":false}'
              SOURCES=$(echo "$SOURCES" | jq ". + [$CORE_SOURCE]")
            else
              echo "‚ö†Ô∏è No existing bookverse-core builds found"
            fi
          fi
          
          # Handle bookverse-devops builds  
          if [[ "${{ needs.build-bookverse-devops.result }}" == "success" ]]; then
            echo "üì¶ Using current bookverse-devops build: ${{ needs.build-bookverse-devops.outputs.build_name }}/${{ needs.build-bookverse-devops.outputs.build_number }}"
            DEVOPS_SOURCE='{"name":"${{ needs.build-bookverse-devops.outputs.build_name }}","number":"${{ needs.build-bookverse-devops.outputs.build_number }}","repository_key":"${{ vars.PROJECT_KEY }}-build-info","include_dependencies":false}'
            SOURCES=$(echo "$SOURCES" | jq ". + [$DEVOPS_SOURCE]")
          elif [[ "${{ needs.build-bookverse-core.result }}" == "success" ]]; then
            # Core build succeeded but devops was skipped - get latest devops build
            echo "üîç bookverse-devops build was skipped, finding latest existing build..."
            LATEST_DEVOPS=$(get_latest_build "bookverse-devops_CI_*")
            if [[ -n "$LATEST_DEVOPS" && "$LATEST_DEVOPS" != "" ]]; then
              DEVOPS_BUILD_NAME="${LATEST_DEVOPS%#*}"
              DEVOPS_BUILD_NUMBER="${LATEST_DEVOPS#*#}"
              echo "üì¶ Using latest bookverse-devops build: $DEVOPS_BUILD_NAME/$DEVOPS_BUILD_NUMBER"
              DEVOPS_SOURCE='{"name":"'$DEVOPS_BUILD_NAME'","number":"'$DEVOPS_BUILD_NUMBER'","repository_key":"${{ vars.PROJECT_KEY }}-build-info","include_dependencies":false}'
              SOURCES=$(echo "$SOURCES" | jq ". + [$DEVOPS_SOURCE]")
            else
              echo "‚ö†Ô∏è No existing bookverse-devops builds found"
            fi
          fi
          
          # Create the application version payload (using simple string format like recommendations service)
          SOURCES_JSON=$(echo "$SOURCES" | jq -c .)
          APP_VERSION_PAYLOAD='{"version":"'$APP_VERSION'","tag":"'$APP_TAG'","sources":{"builds":'$SOURCES_JSON'}}'
          
          echo "üìã Creating application version with payload:"
          echo "$APP_VERSION_PAYLOAD" | jq . || echo "$APP_VERSION_PAYLOAD"
          
          RESP_BODY=$(mktemp)
          HTTP_STATUS=$(curl -sS -L -o "$RESP_BODY" -w "%{http_code}" -X POST \
            "$BASE/applications/$APP_KEY/versions?async=false" \
            -H "Authorization: Bearer $JF_OIDC_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$APP_VERSION_PAYLOAD" \
            --fail-with-body)
          
          echo "üî¢ HTTP Status: $HTTP_STATUS"
          echo "üì® Response Body:"
          cat "$RESP_BODY" | jq . 2>/dev/null || cat "$RESP_BODY"
          echo ""
          
          if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
            echo "‚úÖ Created application version $APP_VERSION"
          else
            echo "‚ö†Ô∏è Application version creation returned HTTP $HTTP_STATUS"
            if [[ "$HTTP_STATUS" == "409" ]]; then
              echo "üìù Version $APP_VERSION already exists, continuing with promotion..."
            else
              echo "‚ùå Failed to create application version" >&2
              rm -f "$RESP_BODY"
              exit 1
            fi
          fi
          rm -f "$RESP_BODY"
          
          echo "üîç Validating application version creation..."
          CONTENT_FILE=$(mktemp)
          CONTENT_STATUS=$(curl -sS -L -o "$CONTENT_FILE" -w "%{http_code}" \
            "$BASE/applications/$APP_KEY/versions/$APP_VERSION/content" \
            -H "Authorization: Bearer $JF_OIDC_TOKEN" \
            -H "Accept: application/json")
          
          if [[ "$CONTENT_STATUS" != "200" ]]; then
            echo "‚ùå Version content endpoint returned HTTP $CONTENT_STATUS for $APP_KEY@$APP_VERSION" >&2
            echo "üì® Response Body:"; cat "$CONTENT_FILE" || true; echo
            rm -f "$CONTENT_FILE"
            exit 1
          fi
          VERSION_STATE=$(jq -r '.status // empty' "$CONTENT_FILE" 2>/dev/null || echo "")
          echo "üì® Version Content:"; cat "$CONTENT_FILE" || true; echo
          rm -f "$CONTENT_FILE"
          if [[ "$VERSION_STATE" != "COMPLETED" ]]; then
            echo "‚ùå Application version not in COMPLETED state (status='$VERSION_STATE') for $APP_KEY@$APP_VERSION" >&2
            exit 1
          fi
          echo "‚úÖ Application version created and validated (COMPLETED): $APP_KEY@$APP_VERSION"

      - name: "[Evidence] Application Version Evidence"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
          EVIDENCE_KEY_ALIAS: ${{ vars.EVIDENCE_KEY_ALIAS }}
        run: |
          echo "üìã Generating evidence for application version (UNASSIGNED stage)"
          
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          
          attach_application_unassigned_evidence
          
          echo "‚úÖ Application version evidence attached via shared library: slsa-provenance, jira-release"

      - name: "[Promote & Evidence] DEV Stage"
        run: |
          echo "üß™ Promoting application to DEV stage with automated evidence collection"
          echo "üìã Application Version: ${{ env.APP_VERSION }}"
          echo "üéØ Target Stage: DEV (development environment for feature testing)"
          echo "üõ°Ô∏è Evidence Type: Smoke tests and basic health validation"
          
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "‚ùå Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          echo "‚úÖ Using JF_OIDC_TOKEN for DEV promotion"
          
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment
          
          if advance_one_step; then
            echo "‚úÖ Successfully promoted to DEV"
          else
            echo "‚ùå Failed to promote to DEV"
            exit 1
          fi
          
          attach_application_dev_evidence
          echo "‚úÖ DEV stage evidence attached via shared library: smoke-tests"

      - name: "[Promote & Evidence] QA Stage"
        run: |
          echo "üîç Promoting to QA stage and generating evidence"
          
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "‚ùå Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          echo "‚úÖ Using JF_OIDC_TOKEN for QA promotion"
          
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment
          
          if advance_one_step; then
            echo "‚úÖ Successfully promoted to QA"
          else
            echo "‚ùå Failed to promote to QA"
            exit 1
          fi
          
          attach_application_qa_evidence
          echo "‚úÖ QA stage evidence attached via shared library: dast-scan, api-tests"

      - name: "[Promote & Evidence] STAGING Stage"
        run: |
          echo "üèóÔ∏è Promoting to STAGING stage and generating evidence"
          
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "‚ùå Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          echo "‚úÖ Using JF_OIDC_TOKEN for STAGING promotion"
          
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment
          
          if advance_one_step; then
            echo "‚úÖ Successfully promoted to STAGING"
          else
            echo "‚ùå Failed to promote to STAGING"
            exit 1
          fi
          
          attach_application_staging_evidence
          echo "‚úÖ STAGING stage evidence attached via shared library: iac-scan, pentest, change-approval"

      - name: "[Promote & Evidence] PROD Stage"
        run: |
          echo "üöÄ Promoting to PROD stage and generating evidence"
          
          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "‚ùå Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          echo "‚úÖ Using JF_OIDC_TOKEN for PROD promotion"
          
          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment
          
          if advance_one_step; then
            echo "‚úÖ Successfully promoted to PROD"
          else
            echo "‚ùå Failed to promote to PROD"
            exit 1
          fi
          
          attach_application_prod_evidence
          echo "‚úÖ PROD stage evidence attached via shared library: deployment-verification"

      - name: "[Summary] Infrastructure Deployment Complete"
        run: |
          echo "## üèóÔ∏è BookVerse Infrastructure CI/CD Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìä Application Version" >> $GITHUB_STEP_SUMMARY
          echo "- **Application**: \`bookverse-infra\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: \`${{ env.APP_VERSION }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Trigger**: ${{ needs.analyze-commit.outputs.decision_reason }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Final Stage**: PROD ‚úÖ" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìö Infrastructure Libraries Built" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.build-bookverse-core.result }}" == "success" ]]; then
            echo "- **bookverse-core**: v${{ needs.build-bookverse-core.outputs.package_version }} (Coverage: ${{ needs.build-bookverse-core.outputs.coverage_percent }}%)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **bookverse-core**: Skipped (no changes)" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.build-bookverse-devops.result }}" == "success" ]]; then
            echo "- **bookverse-devops**: v${{ needs.build-bookverse-devops.outputs.package_version }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **bookverse-devops**: Skipped (no changes)" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîÑ Lifecycle Progression" >> $GITHUB_STEP_SUMMARY
          echo "- **UNASSIGNED**: Evidence attached (SLSA provenance, Jira release)" >> $GITHUB_STEP_SUMMARY
          echo "- **DEV**: Promoted ‚úÖ + Evidence (smoke tests)" >> $GITHUB_STEP_SUMMARY
          echo "- **QA**: Promoted ‚úÖ + Evidence (DAST scan, API tests)" >> $GITHUB_STEP_SUMMARY
          echo "- **STAGING**: Promoted ‚úÖ + Evidence (IaC scan, pentest, change approval)" >> $GITHUB_STEP_SUMMARY
          echo "- **PROD**: Promoted ‚úÖ + Evidence (deployment verification)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üéØ Infrastructure Ready" >> $GITHUB_STEP_SUMMARY
          echo "- Infrastructure libraries available in JFrog Artifactory" >> $GITHUB_STEP_SUMMARY
          echo "- Services can consume bookverse-core and bookverse-devops libraries" >> $GITHUB_STEP_SUMMARY
          echo "- Full evidence trail collected across all lifecycle stages" >> $GITHUB_STEP_SUMMARY
          echo "- Application successfully deployed to PROD" >> $GITHUB_STEP_SUMMARY