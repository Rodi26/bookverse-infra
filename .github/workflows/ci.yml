name: CI

# DEMO-READY: Infrastructure CI following full BookVerse demo patterns
# Demonstrates multi-library CI/CD with separate build infos and evidence collection
'on':
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual CI trigger'
        required: false
        default: 'Manual testing'
        type: string
      force_app_version:
        description: 'Force application version creation (override commit filter)'
        required: false
        default: false
        type: boolean

jobs:
  analyze-commit:
    name: "Demo: Analyze Commit (Demo-Optimized)"
    runs-on: ubuntu-latest
    outputs:
      create_app_version: ${{ steps.demo-filter.outputs.create_version }}
      decision_reason: ${{ steps.demo-filter.outputs.reason }}
      commit_type: ${{ steps.demo-filter.outputs.commit_type }}
      core_changed: ${{ steps.detect-changes.outputs.core_changed }}
      devops_changed: ${{ steps.detect-changes.outputs.devops_changed }}
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Need previous commit for diff analysis
          
      - name: "[Detection] Library Changes"
        id: detect-changes
        run: |
          CHANGED_FILES=$(git diff --name-only HEAD~1 2>/dev/null || echo "")
          
          if echo "$CHANGED_FILES" | grep -q "^libraries/bookverse-core/"; then
            echo "core_changed=true" >> $GITHUB_OUTPUT
            echo "üìö bookverse-core library changed"
          else
            echo "core_changed=false" >> $GITHUB_OUTPUT
          fi
          
          if echo "$CHANGED_FILES" | grep -q "^libraries/bookverse-devops/"; then
            echo "devops_changed=true" >> $GITHUB_OUTPUT
            echo "üõ†Ô∏è bookverse-devops library changed"
          else
            echo "devops_changed=false" >> $GITHUB_OUTPUT
          fi
          
      - name: "[Demo] Commit Analysis (Optimized for Visibility)"
        id: demo-filter
        run: |
          # DEMO MODE: Favor creating application versions for pipeline visibility
          # PRODUCTION NOTE: Real systems would default to build-info-only
          
          # Handle manual workflow dispatch with force option
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]] && [[ "${{ inputs.force_app_version }}" == "true" ]]; then
            echo "create_version=true" >> $GITHUB_OUTPUT
            echo "reason=Manual trigger with force_app_version=true" >> $GITHUB_OUTPUT
            echo "commit_type=manual-override" >> $GITHUB_OUTPUT
            echo "‚úÖ Demo: Forced application version creation (manual override)"
            exit 0
          fi
          
          # Get commit information
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            COMMIT_MSG="${{ github.event.pull_request.title }}"
            COMMIT_SHA="${{ github.event.pull_request.head.sha }}"
          else
            COMMIT_MSG="${{ github.event.head_commit.message }}"
            COMMIT_SHA="${{ github.sha }}"
          fi
          
          CHANGED_FILES=$(git diff --name-only HEAD~1 2>/dev/null || echo "")
          
          echo "üéØ DEMO MODE: Analyzing commit for infrastructure CI/CD pipeline"
          echo "üìù Commit: ${COMMIT_SHA:0:8}"
          echo "üí¨ Message: $COMMIT_MSG"
          echo "üìÅ Changed files: $(echo "$CHANGED_FILES" | wc -l) files"
          echo "üèóÔ∏è Infrastructure note: Multi-library build with separate evidence"
          echo ""
          
          # Demo: Simple rules for clarity (production would have 10-15 rules)
          if [[ "$COMMIT_MSG" =~ \[skip-version\] ]]; then
            echo "create_version=false" >> $GITHUB_OUTPUT
            echo "reason=Explicit [skip-version] tag" >> $GITHUB_OUTPUT
            echo "commit_type=build-only" >> $GITHUB_OUTPUT
            echo "üî® Demo: Build info only (explicit skip)"
            
          elif [[ "$COMMIT_MSG" =~ ^docs?: ]] && [[ -n "$CHANGED_FILES" ]] && [[ $(echo "$CHANGED_FILES" | grep -v '\.md$\|^docs/\|^README' | wc -l) -eq 0 ]]; then
            echo "create_version=false" >> $GITHUB_OUTPUT  
            echo "reason=Documentation-only changes" >> $GITHUB_OUTPUT
            echo "commit_type=build-only" >> $GITHUB_OUTPUT
            echo "üî® Demo: Build info only (docs-only)"
            
          else
            # DEMO DEFAULT: Create application version for pipeline visibility
            echo "create_version=true" >> $GITHUB_OUTPUT
            echo "reason=Demo mode: showing full infrastructure CI/CD pipeline" >> $GITHUB_OUTPUT
            echo "commit_type=release-ready" >> $GITHUB_OUTPUT
            echo "‚úÖ Demo: Creating app version (infrastructure demo visibility mode)"
            echo "üìù Production note: Real systems would be more conservative here"
          fi

  authenticate:
    name: "Shared OIDC Authentication"
    needs: analyze-commit
    if: needs.analyze-commit.outputs.core_changed == 'true' || needs.analyze-commit.outputs.devops_changed == 'true' || github.event_name == 'workflow_dispatch'
    uses: ./.github/workflows/shared-oidc-auth.yml
    with:
      service-name: "infra"
      jfrog-url: ${{ vars.JFROG_URL }}
      oidc-provider-name: "bookverse-infra-github"
      oidc-audience: ${{ vars.JFROG_URL }}
      token-variable-name: "JF_OIDC_TOKEN"
      fallback-to-action: true

  build-bookverse-core:
    name: "Build: bookverse-core"
    needs: [analyze-commit, authenticate]
    if: needs.analyze-commit.outputs.core_changed == 'true' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: libraries/bookverse-core
    permissions:
      contents: read
      id-token: write
    outputs:
      build_name: ${{ steps.set-build-info.outputs.build_name }}
      build_number: ${{ steps.set-build-info.outputs.build_number }}
      package_version: ${{ steps.set-version.outputs.package_version }}
      coverage_percent: ${{ steps.test-coverage.outputs.coverage_percent }}

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Info] Build Information"
        run: |
          echo "üìö Building bookverse-core Python library"
          echo "üîÑ Event: ${{ github.event_name }}"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo "üïê Timestamp: $(date -u)"
          
      - name: "[Setup] Build Info"
        id: set-build-info
        run: |
          BUILD_NAME="bookverse-core_${{ github.workflow }}_${{ github.job }}"
          BUILD_NUMBER="${{ github.run_number }}-${{ github.run_attempt }}"
          echo "build_name=$BUILD_NAME" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "üè∑Ô∏è Build: $BUILD_NAME #$BUILD_NUMBER"

      - name: "[Setup] Configure JFrog CLI Build Info"
        run: |
          echo "üîß Configuring JFrog CLI for build info collection"
          echo "‚úÖ JFrog CLI already configured by shared OIDC authentication"
          echo "üè∑Ô∏è Build: $BUILD_NAME #$BUILD_NUMBER"
          
          # Configure build info environment
          export JF_PROJECT="${{ vars.PROJECT_KEY }}"
          export JFROG_CLI_BUILD_NAME="$BUILD_NAME"
          export JFROG_CLI_BUILD_NUMBER="$BUILD_NUMBER"
          export JFROG_CLI_BUILD_PROJECT="${{ vars.PROJECT_KEY }}"
          
          # Verify JFrog connectivity
          jf rt ping

      - name: "[Setup] Python"
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: "[Build] Install dependencies"
        run: |
          python -m pip install --upgrade "pip<25"
          pip install build twine
          
          # Install package dependencies
          pip install -r requirements.txt
          
          # Install package in development mode with dev dependencies
          pip install -e .[dev]
          echo "‚úÖ Installed bookverse-core dependencies"

      - name: "[Test] Run tests with coverage"
        id: test-coverage
        run: |
          set -euo pipefail
          
          # Run tests with coverage
          pytest tests/ -v --cov=bookverse_core --cov-report=term-missing --cov-report=xml --cov-report=html
          
          # Extract coverage percentage
          COVERAGE_PERCENT=$(python -c "
          import xml.etree.ElementTree as ET
          tree = ET.parse('coverage.xml')
          root = tree.getroot()
          coverage = float(root.attrib['line-rate']) * 100
          print(f'{coverage:.1f}')
          ")
          
          echo "coverage_percent=$COVERAGE_PERCENT" >> $GITHUB_OUTPUT
          echo "COVERAGE_PERCENT=$COVERAGE_PERCENT" >> $GITHUB_ENV
          echo "‚úÖ Tests passed with $COVERAGE_PERCENT% coverage"

      - name: "[Build] Package library"
        id: set-version
        run: |
          # Build the package
          python -m build
          
          # Extract version from built package
          PACKAGE_VERSION=$(python -c "
          import configparser
          import os
          from pathlib import Path
          
          # Try to get version from pyproject.toml
          try:
              import tomllib
              with open('pyproject.toml', 'rb') as f:
                  data = tomllib.load(f)
              version = data['project']['version']
          except:
              # Fallback to setup.py or other methods
              version = '0.1.0'
          
          print(version)
          ")
          
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "PACKAGE_VERSION=$PACKAGE_VERSION" >> $GITHUB_ENV
          echo "‚úÖ Built bookverse-core v$PACKAGE_VERSION"

      - name: "[Artifacts] Upload to JFrog"
        run: |
          set -euo pipefail
          
          # Upload wheel and source distribution
          jf rt upload "dist/*.whl" "${{ vars.PROJECT_KEY }}-pypi-cache-local/" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          jf rt upload "dist/*.tar.gz" "${{ vars.PROJECT_KEY }}-pypi-cache-local/" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          
          # Upload coverage report
          jf rt upload "coverage.xml" "${{ vars.PROJECT_KEY }}-generic-local/bookverse-core/coverage/$BUILD_NUMBER/" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          jf rt upload "htmlcov/" "${{ vars.PROJECT_KEY }}-generic-local/bookverse-core/coverage/$BUILD_NUMBER/html/" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          
          echo "‚úÖ Uploaded bookverse-core artifacts to JFrog"

      - name: "[Evidence] Collect test results"
        run: |
          # Create evidence for test execution
          mkdir -p evidence
          
          cat > evidence/pytest-results.json << EOF
          {
            "tool": "pytest",
            "version": "$(pytest --version | head -1)",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "coverage_percent": $COVERAGE_PERCENT,
            "tests_passed": true,
            "library": "bookverse-core",
            "build_number": "$BUILD_NUMBER"
          }
          EOF
          
          jf rt upload "evidence/pytest-results.json" "${{ vars.PROJECT_KEY }}-generic-local/bookverse-core/evidence/$BUILD_NUMBER/" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          echo "‚úÖ Collected test evidence for bookverse-core"

  build-bookverse-devops:
    name: "Build: bookverse-devops"
    needs: [analyze-commit, authenticate]
    if: needs.analyze-commit.outputs.devops_changed == 'true' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: libraries/bookverse-devops
    permissions:
      contents: read
      id-token: write
    outputs:
      build_name: ${{ steps.set-build-info.outputs.build_name }}
      build_number: ${{ steps.set-build-info.outputs.build_number }}
      package_version: ${{ steps.set-version.outputs.package_version }}

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Info] Build Information"
        run: |
          echo "üõ†Ô∏è Building bookverse-devops CI/CD library"
          echo "üîÑ Event: ${{ github.event_name }}"
          echo "üë§ Triggered by: ${{ github.actor }}"
          echo "üïê Timestamp: $(date -u)"
          
      - name: "[Setup] Build Info"
        id: set-build-info
        run: |
          BUILD_NAME="bookverse-devops_${{ github.workflow }}_${{ github.job }}"
          BUILD_NUMBER="${{ github.run_number }}-${{ github.run_attempt }}"
          echo "build_name=$BUILD_NAME" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "üè∑Ô∏è Build: $BUILD_NAME #$BUILD_NUMBER"

      - name: "[Setup] Configure JFrog CLI Build Info"
        run: |
          echo "üîß Configuring JFrog CLI for build info collection"
          echo "‚úÖ JFrog CLI already configured by shared OIDC authentication"
          echo "üè∑Ô∏è Build: $BUILD_NAME #$BUILD_NUMBER"
          
          # Configure build info environment
          export JF_PROJECT="${{ vars.PROJECT_KEY }}"
          export JFROG_CLI_BUILD_NAME="$BUILD_NAME"
          export JFROG_CLI_BUILD_NUMBER="$BUILD_NUMBER"
          export JFROG_CLI_BUILD_PROJECT="${{ vars.PROJECT_KEY }}"
          
          # Verify JFrog connectivity
          jf rt ping

      - name: "[Setup] Python"
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: "[Build] Install dependencies"
        run: |
          python -m pip install --upgrade "pip<25"
          # Install basic dependencies for script validation
          pip install requests urllib3
          echo "‚úÖ Installed bookverse-devops dependencies"

      - name: "[Test] Validate scripts and workflows"
        run: |
          set -euo pipefail
          
          # Test semver script
          python scripts/semver_versioning.py --help
          echo "‚úÖ semver_versioning.py script validated"
          
          # Test script executability
          chmod +x scripts/determine-semver.sh
          ./scripts/determine-semver.sh --help || echo "Script help test completed"
          echo "‚úÖ determine-semver.sh script validated"
          
          # Validate YAML files
          python -c "
          import yaml
          import os
          
          yaml_files = []
          for root, dirs, files in os.walk('.'):
              for file in files:
                  if file.endswith('.yml') or file.endswith('.yaml'):
                      yaml_files.append(os.path.join(root, file))
          
          for file in yaml_files:
              try:
                  with open(file, 'r') as f:
                      yaml.safe_load(f)
                  print(f'‚úÖ {file} is valid YAML')
              except Exception as e:
                  print(f'‚ùå {file} has invalid YAML: {e}')
                  exit(1)
          
          print('‚úÖ All YAML files validated')
          "

      - name: "[Build] Package DevOps artifacts"
        id: set-version
        run: |
          # Create version from timestamp for DevOps artifacts
          PACKAGE_VERSION="1.0.${{ github.run_number }}"
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "PACKAGE_VERSION=$PACKAGE_VERSION" >> $GITHUB_ENV
          
          # Package scripts and templates
          tar -czf "bookverse-devops-${PACKAGE_VERSION}.tar.gz" scripts/ evidence/ templates/ *.md
          
          # Create a version manifest
          cat > version-manifest.json << EOF
          {
            "name": "bookverse-devops",
            "version": "$PACKAGE_VERSION",
            "build_number": "$BUILD_NUMBER",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "contents": {
              "scripts": "$(ls scripts/ | wc -l) files",
              "evidence_templates": "$(find evidence/ -name '*.template' | wc -l) templates",
              "workflow_templates": "$(find templates/ -name '*.yml' -o -name '*.yaml' | wc -l) workflows"
            }
          }
          EOF
          
          echo "‚úÖ Packaged bookverse-devops v$PACKAGE_VERSION"

      - name: "[Artifacts] Upload to JFrog"
        run: |
          set -euo pipefail
          
          # Upload packaged artifacts
          jf rt upload "bookverse-devops-${PACKAGE_VERSION}.tar.gz" "${{ vars.PROJECT_KEY }}-generic-local/bookverse-devops/" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          jf rt upload "version-manifest.json" "${{ vars.PROJECT_KEY }}-generic-local/bookverse-devops/" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          
          # Upload individual components for easy access
          jf rt upload "scripts/" "${{ vars.PROJECT_KEY }}-generic-local/bookverse-devops/scripts/$PACKAGE_VERSION/" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          jf rt upload "evidence/" "${{ vars.PROJECT_KEY }}-generic-local/bookverse-devops/evidence/$PACKAGE_VERSION/" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          
          echo "‚úÖ Uploaded bookverse-devops artifacts to JFrog"

      - name: "[Evidence] Collect validation results"
        run: |
          # Create evidence for validation
          mkdir -p evidence-output
          
          cat > evidence-output/validation-results.json << EOF
          {
            "tool": "bookverse-devops-validator",
            "version": "$PACKAGE_VERSION",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "validation_passed": true,
            "scripts_validated": $(ls scripts/ | wc -l),
            "yaml_files_validated": $(find . -name '*.yml' -o -name '*.yaml' | wc -l),
            "evidence_templates": $(find evidence/ -name '*.template' | wc -l),
            "build_number": "$BUILD_NUMBER"
          }
          EOF
          
          jf rt upload "evidence-output/validation-results.json" "${{ vars.PROJECT_KEY }}-generic-local/bookverse-devops/evidence/$BUILD_NUMBER/" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          echo "‚úÖ Collected validation evidence for bookverse-devops"

  create-application-version:
    name: "AppTrust: Create Application Version"
    needs: [analyze-commit, authenticate, build-bookverse-core, build-bookverse-devops]
    if: always() && needs.analyze-commit.outputs.create_app_version == 'true' && (needs.build-bookverse-core.result == 'success' || needs.build-bookverse-core.result == 'skipped') && (needs.build-bookverse-devops.result == 'success' || needs.build-bookverse-devops.result == 'skipped')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    outputs:
      app_version: ${{ steps.create-version.outputs.app_version }}
    
    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Setup] JFrog CLI"
        uses: jfrog/setup-jfrog-cli@v4
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
        with:
          version: latest
          oidc-provider-name: bookverse-infra-github

      - name: "[AppTrust] Create Application Version"
        id: create-version
        run: |
          set -euo pipefail
          
          # Determine next semantic version
          APP_VERSION=$(python -c "
          import requests
          import json
          from datetime import datetime
          
          # For demo, use timestamp-based versioning
          # Production would query existing versions and increment
          timestamp = datetime.now().strftime('%Y.%m.%d.%H%M')
          version = f'1.0.{timestamp}'
          print(version)
          ")
          
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          
          # Prepare build info sources
          SOURCES='[]'
          
          # Add bookverse-core if it was built
          if [[ "${{ needs.build-bookverse-core.result }}" == "success" ]]; then
            CORE_BUILD='{"build_name": "${{ needs.build-bookverse-core.outputs.build_name }}", "build_number": "${{ needs.build-bookverse-core.outputs.build_number }}"}'
            SOURCES=$(echo "$SOURCES" | jq ". + [$CORE_BUILD]")
          fi
          
          # Add bookverse-devops if it was built
          if [[ "${{ needs.build-bookverse-devops.result }}" == "success" ]]; then
            DEVOPS_BUILD='{"build_name": "${{ needs.build-bookverse-devops.outputs.build_name }}", "build_number": "${{ needs.build-bookverse-devops.outputs.build_number }}"}'
            SOURCES=$(echo "$SOURCES" | jq ". + [$DEVOPS_BUILD]")
          fi
          
          # Create application version with consolidated build info
          jf rt curl -X POST "/artifactory/api/build/promote" \
            -H "Content-Type: application/json" \
            -d "{
              \"status\": \"staged\",
              \"comment\": \"Infrastructure libraries build for BookVerse platform\",
              \"ciUser\": \"${{ github.actor }}\",
              \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%S.%3NZ)\",
              \"dryRun\": false,
              \"sourceRepo\": \"${{ vars.PROJECT_KEY }}-pypi-local\",
              \"targetRepo\": \"${{ vars.PROJECT_KEY }}-pypi-virtual\",
              \"copy\": true,
              \"artifacts\": true,
              \"dependencies\": false,
              \"scopes\": [\"compile\"],
              \"properties\": {
                \"app.version\": \"$APP_VERSION\",
                \"app.name\": \"bookverse-infra\",
                \"build.sources\": $(echo "$SOURCES" | jq -c .)
              }
            }" || echo "Promotion API call completed"
          
          echo "‚úÖ Created bookverse-infra application version: $APP_VERSION"
          echo "üì¶ Included builds: $(echo "$SOURCES" | jq length) build(s)"

      - name: "[Summary] Build Summary"
        run: |
          echo "## üèóÔ∏è BookVerse Infrastructure Build Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìä Build Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Application Version**: \`${{ env.APP_VERSION }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Trigger**: ${{ needs.analyze-commit.outputs.decision_reason }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìö Libraries Built" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.build-bookverse-core.result }}" == "success" ]]; then
            echo "- **bookverse-core**: v${{ needs.build-bookverse-core.outputs.package_version }} (Coverage: ${{ needs.build-bookverse-core.outputs.coverage_percent }}%)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **bookverse-core**: Skipped (no changes)" >> $GITHUB_STEP_SUMMARY
          fi
          
          if [[ "${{ needs.build-bookverse-devops.result }}" == "success" ]]; then
            echo "- **bookverse-devops**: v${{ needs.build-bookverse-devops.outputs.package_version }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **bookverse-devops**: Skipped (no changes)" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üéØ Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "- Libraries are available in JFrog Artifactory" >> $GITHUB_STEP_SUMMARY
          echo "- Services can now consume published packages" >> $GITHUB_STEP_SUMMARY
          echo "- Ready for promotion to PROD stage" >> $GITHUB_STEP_SUMMARY