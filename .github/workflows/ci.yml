# =============================================================================
# BookVerse Infrastructure - Comprehensive CI/CD Workflow
# =============================================================================
#
# This GitHub Actions workflow provides complete CI/CD automation for the BookVerse
# Infrastructure repository, implementing enterprise-grade multi-package builds,
# shared library management, and foundational artifact publication that supports
# all BookVerse platform services and provides critical development tooling.
#
# 🏗️ WORKFLOW ARCHITECTURE:
#     - Multi-Package Management: Coordinated builds for multiple infrastructure packages
#     - Shared Library Publishing: Common utilities and patterns for all services
#     - DevOps Automation: Centralized scripts and tooling for platform operations
#     - Evidence Collection: Cryptographic signing and comprehensive infrastructure audit trails
#     - AppTrust Integration: Automated lifecycle management for foundational components
#     - Dependency Management: Version coordination and compatibility validation
#
# 🚀 KEY FEATURES:
#     - Enterprise-grade infrastructure library development with dependency management
#     - Comprehensive testing framework for shared utilities and common patterns
#     - Advanced multi-package versioning with semantic version coordination
#     - Automated GitHub Actions and reusable workflow publishing
#     - Centralized DevOps script validation and distribution management
#     - Zero-dependency deployment tooling for cross-service compatibility
#
# 📊 BUSINESS LOGIC:
#     - Platform Foundation: Core infrastructure supporting all BookVerse services
#     - Development Velocity: Shared utilities accelerating service development
#     - Operational Excellence: Centralized tooling ensuring consistent operations
#     - Quality Assurance: Common testing patterns and validation frameworks
#     - Security Standards: Shared security utilities and compliance frameworks
#     - Deployment Coordination: Infrastructure patterns enabling reliable deployments
#
# 🛠️ USAGE PATTERNS:
#     - Service Development: Shared libraries imported by all BookVerse services
#     - DevOps Operations: Centralized scripts for platform management and automation
#     - CI/CD Pipeline: Reusable workflows and actions consumed by service repositories
#     - Testing Infrastructure: Common test utilities and validation frameworks
#     - Security Integration: Shared security patterns and compliance tooling
#
# ⚡ TRIGGER CONDITIONS:
#     - Push to Main: Automatic validation and publication of infrastructure updates
#     - Pull Requests: Comprehensive testing of proposed infrastructure changes
#     - Manual Dispatch: On-demand builds for infrastructure testing and validation
#     - Dependency Updates: Automated validation when shared dependencies change
#
# 🔧 ENVIRONMENT VARIABLES:
#     - PROJECT_KEY: BookVerse project identifier for JFrog integration
#     - JFROG_URL: JFrog Platform URL for infrastructure artifact and evidence management
#     - GITHUB_TOKEN: GitHub authentication for repository operations
#     - PACKAGE_REGISTRY: Multi-package registry configuration for library distribution
#
# 📈 SUCCESS CRITERIA:
#     - Library Tests: All shared library packages pass comprehensive validation
#     - Compatibility Tests: Cross-service integration and dependency validation
#     - Security Compliance: Infrastructure security scanning and vulnerability assessment
#     - Performance Validation: Shared utility performance meets efficiency requirements
#     - Documentation Coverage: Complete API documentation for all published libraries
#
# 🏛️ INFRASTRUCTURE SPECIFIC FEATURES:
#     - Multi-Package Coordination: Synchronized versioning across multiple library packages
#     - Shared Utility Libraries: Common patterns for database, API, authentication, and logging
#     - DevOps Script Collection: Centralized automation scripts for platform operations
#     - GitHub Actions Library: Reusable workflow components and custom actions
#     - Configuration Management: Shared configuration patterns and environment utilities
#     - Testing Frameworks: Common testing utilities and validation patterns
#
# Authors: BookVerse Platform Team
# Version: 1.0.0
#
name: CI

# 🔄 Concurrency Control: Ensures only one CI build runs per repository at a time
# Prevents infrastructure conflicts and ensures consistent multi-package testing results
concurrency:
  group: ci-${{ vars.PROJECT_KEY }}-${{ github.repository }}
  cancel-in-progress: true

# ⚡ Workflow Triggers: Defines when the infrastructure CI pipeline should execute
# Optimized for continuous validation of shared libraries and foundational components
on:
  # 📤 Push Events: Automatic validation when infrastructure code is updated on main branch
  push:
    branches: [main]

  # 🔍 Pull Request Events: Comprehensive testing of proposed infrastructure changes
  # Ensures shared library quality and compatibility before merging into main branch
  pull_request:
    branches: [main]

  # 🎛️ Manual Dispatch: On-demand execution for infrastructure testing and library validation
  # Supports manual deployment and cross-service compatibility validation scenarios
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for manual CI trigger'
        required: false
        default: 'Manual testing'
        type: string
      force_app_version:
        description: 'Force application version creation (override commit filter)'
        required: false
        default: false  # Conservative default for infrastructure changes
        type: boolean

jobs:
  # 🔍 Job: Intelligent Commit Analysis for Infrastructure Library Deployment Decisions
  # This job analyzes commits to determine whether infrastructure library changes warrant
  # creating new application versions for deployment. Critical for managing shared library
  # compatibility and ensuring safe deployment of foundational component updates.
  # Key outputs: deployment decision, commit classification, library change detection
  analyze-commit:
    name: "Demo: Analyze Commit (Demo-Optimized)"
    runs-on: ubuntu-latest
    outputs:
      create_app_version: ${{ steps.demo-filter.outputs.create_version }}
      decision_reason: ${{ steps.demo-filter.outputs.reason }}
      commit_type: ${{ steps.demo-filter.outputs.commit_type }}
      core_changed: ${{ steps.detect-changes.outputs.core_changed }}
      devops_changed: ${{ steps.detect-changes.outputs.devops_changed }}
    steps:
      # 📥 Setup: Repository checkout for infrastructure system analysis
      # Fetches infrastructure repository source code with commit history
      # for intelligent analysis of shared library and tooling changes
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4
        with:
          fetch-depth: 2  # Shallow clone with history for library change comparison

      # 🔍 Detection: Infrastructure library change analysis and impact assessment
      # Analyzes changed files to determine which infrastructure libraries are affected
      # Critical for coordinating multi-package builds and dependency management
      - name: "[Detection] Library Changes"
        id: detect-changes
        run: |
          # 📋 Change detection: Identify modified files for library impact analysis
          CHANGED_FILES=$(git diff --name-only HEAD~1 2>/dev/null || echo "")

          # 📚 Core library analysis: Check for bookverse-core shared library changes
          # Determines if foundational utilities and common patterns were modified
          if echo "$CHANGED_FILES" | grep -q "^libraries/bookverse-core/"; then
            echo "core_changed=true" >> $GITHUB_OUTPUT
            echo "📚 bookverse-core library changed"
          else
            echo "core_changed=false" >> $GITHUB_OUTPUT
          fi

          # 🛠️ DevOps library analysis: Check for bookverse-devops automation changes
          # Determines if DevOps scripts, workflows, and operational tooling were modified
          if echo "$CHANGED_FILES" | grep -q "^libraries/bookverse-devops/"; then
            echo "devops_changed=true" >> $GITHUB_OUTPUT
            echo "🛠️ bookverse-devops library changed"
          else
            echo "devops_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: "[Demo] Commit Analysis (Optimized for Visibility)"
        id: demo-filter
        run: |

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]] && [[ "${{ inputs.force_app_version }}" == "true" ]]; then
            echo "create_version=true" >> $GITHUB_OUTPUT
            echo "reason=Manual trigger with force_app_version=true" >> $GITHUB_OUTPUT
            echo "commit_type=manual-override" >> $GITHUB_OUTPUT
            echo "✅ Demo: Forced application version creation (manual override)"
            exit 0
          fi

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            COMMIT_MSG="${{ github.event.pull_request.title }}"
            COMMIT_SHA="${{ github.event.pull_request.head.sha }}"
          else
            COMMIT_MSG="${{ github.event.head_commit.message }}"
            COMMIT_SHA="${{ github.sha }}"
          fi

          CHANGED_FILES=$(git diff --name-only HEAD~1 2>/dev/null || echo "")

          echo "🎯 DEMO MODE: Analyzing commit for infrastructure CI/CD pipeline"
          echo "📝 Commit: ${COMMIT_SHA:0:8}"
          echo "💬 Message: $COMMIT_MSG"
          echo "📁 Changed files: $(echo "$CHANGED_FILES" | wc -l) files"
          echo "🏗️ Infrastructure note: Multi-library build with separate evidence"
          echo ""

          if [[ "$COMMIT_MSG" =~ \[skip-version\] ]]; then
            echo "create_version=false" >> $GITHUB_OUTPUT
            echo "reason=Explicit [skip-version] tag" >> $GITHUB_OUTPUT
            echo "commit_type=build-only" >> $GITHUB_OUTPUT
            echo "🔨 Demo: Build info only (explicit skip)"

          elif [[ "$COMMIT_MSG" =~ ^docs?: ]] && [[ -n "$CHANGED_FILES" ]] && [[ $(echo "$CHANGED_FILES" | grep -v '\.md$\|^docs/\|^README' | wc -l) -eq 0 ]]; then
            echo "create_version=false" >> $GITHUB_OUTPUT  
            echo "reason=Documentation-only changes" >> $GITHUB_OUTPUT
            echo "commit_type=build-only" >> $GITHUB_OUTPUT
            echo "🔨 Demo: Build info only (docs-only)"

          else
            echo "create_version=true" >> $GITHUB_OUTPUT
            echo "reason=Demo mode: showing full infrastructure CI/CD pipeline" >> $GITHUB_OUTPUT
            echo "commit_type=release-ready" >> $GITHUB_OUTPUT
            echo "✅ Demo: Creating app version (infrastructure demo visibility mode)"
            echo "📝 Production note: Real systems would be more conservative here"
          fi

  # 🏗️ Job: BookVerse Core Library Build, Test, and Publication
  # This job builds and publishes the foundational bookverse-core Python library
  # that provides shared utilities, common patterns, and essential infrastructure
  # components used by all BookVerse services. Critical for maintaining consistent
  # development patterns and operational excellence across the platform.
  # Key outputs: core library package, test coverage, version information
  build-bookverse-core:
    name: "Build: bookverse-core"
    needs: [analyze-commit]
    # 🎯 Conditional execution: Only runs when core library changes are detected
    if: needs.analyze-commit.outputs.core_changed == 'true' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: libraries/bookverse-core  # Focus on core library directory
    # 🔐 Security: OIDC permissions for JFrog authentication and library publishing
    permissions:
      contents: read      # Repository content access for library source code
      id-token: write    # OIDC token generation for JFrog authentication
    outputs:
      build_name: ${{ steps.set-build-info.outputs.build_name }}
      build_number: ${{ steps.set-build-info.outputs.build_number }}
      package_version: ${{ steps.set-version.outputs.package_version }}
      coverage_percent: ${{ steps.test-coverage.outputs.coverage_percent }}

    steps:
      # 📥 Setup: Repository checkout for core library source code
      # Retrieves complete infrastructure repository including
      # core library implementation and shared utility patterns
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      # ℹ️ Information: Core library build context and operational details
      # Displays comprehensive context about shared library build process
      # Critical for understanding foundational component deployment workflow
      - name: "[Info] Build Information"
        run: |
          echo "📚 Building bookverse-core Python library"
          echo "🔄 Event: ${{ github.event_name }}"
          echo "👤 Triggered by: ${{ github.actor }}"
          echo "🕐 Timestamp: $(date -u)"

      - name: "[Setup] Build Info"
        id: set-build-info
        run: |
          BUILD_NAME="bookverse-core_${{ github.workflow }}_${{ github.job }}"
          BUILD_NUMBER="${{ github.run_number }}-${{ github.run_attempt }}"
          echo "build_name=$BUILD_NAME" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "🏷️ Build: $BUILD_NAME"

      - name: "[Setup] Install and Configure JFrog CLI"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ env.BUILD_NAME }}
          JFROG_CLI_BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          JFROG_CLI_BUILD_PROJECT: ${{ vars.PROJECT_KEY }}
        with:
          version: latest
          oidc-provider-name: bookverse-infra-github
          oidc-audience: ${{ vars.JFROG_URL }}
          disable-job-summary: false
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false

      - name: "[Setup] Verify JFrog CLI Configuration"
        run: |
          echo "🔧 Verifying JFrog CLI configuration"
          echo "✅ JFrog CLI installed and configured with OIDC authentication"
          echo "🏷️ Build: $BUILD_NAME"

          jf rt ping

      - name: "[Setup] Python"
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: "[Build] Install dependencies"
        run: |
          python -m pip install --upgrade "pip<25"
          pip install build twine

          pip install -r requirements.txt

          pip install -e .[dev]
          echo "✅ Installed bookverse-core dependencies"

      - name: "[Test] Run tests with coverage"
        id: test-coverage
        run: |
          set -euo pipefail

          pytest tests/ -v --cov=bookverse_core --cov-report=term-missing --cov-report=xml --cov-report=html

          COVERAGE_PERCENT=$(python -c "
          import xml.etree.ElementTree as ET
          tree = ET.parse('coverage.xml')
          root = tree.getroot()
          coverage = float(root.attrib['line-rate']) * 100
          print(f'{coverage:.1f}')
          ")

          echo "coverage_percent=$COVERAGE_PERCENT" >> $GITHUB_OUTPUT
          echo "COVERAGE_PERCENT=$COVERAGE_PERCENT" >> $GITHUB_ENV
          echo "✅ Tests passed with $COVERAGE_PERCENT% coverage"

      - name: "[Build] Package library"
        id: set-version
        run: |
          python -m build

          PACKAGE_VERSION=$(python -c "
          import configparser
          import os
          from pathlib import Path

          try:
              import tomllib
              with open('pyproject.toml', 'rb') as f:
                  data = tomllib.load(f)
              version = data['project']['version']
          except:
              version = '0.1.0'

          print(version)
          ")

          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "PACKAGE_VERSION=$PACKAGE_VERSION" >> $GITHUB_ENV
          echo "✅ Built bookverse-core v$PACKAGE_VERSION"

      - name: "[Artifacts] Upload to JFrog"
        run: |
          set -euo pipefail

          jf rt upload "dist/*.whl" "${{ vars.PROJECT_KEY }}-core-internal-python-nonprod-local/" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"
          jf rt upload "dist/*.tar.gz" "${{ vars.PROJECT_KEY }}-core-internal-python-nonprod-local/" --build-name "$BUILD_NAME" --build-number "$BUILD_NUMBER"

          echo "ℹ️  Coverage upload temporarily disabled - repository not available"

          echo "✅ Uploaded bookverse-core artifacts to JFrog"

      - name: "[Build] Publish Build Info"
        run: |
          set -euo pipefail

          echo "📋 Publishing build-info for bookverse-core library"
          echo "🏗️ Build: $BUILD_NAME/$BUILD_NUMBER"
          echo "📦 Contains: Python wheel + source distribution + test coverage"

          jf rt bag --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          jf rt bce --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          if BUILD_PUBLISH_RESULT=$(jf rt bp --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"); then
            echo "BUILD_INFO_PUBLISH_STATUS=SUCCESS" >> $GITHUB_ENV
            BUILD_UI_URL=$(echo "$BUILD_PUBLISH_RESULT" | grep -o 'https://[^[:space:]]*builds/[^[:space:]]*' | head -1 || echo "")

            if [[ -n "$BUILD_UI_URL" ]]; then
              EPOCH_MS=$(echo "$BUILD_UI_URL" | sed -n 's|.*/builds/[^/]*/[^/]*/\([0-9]*\)/published.*|\1|p')

              if [[ -n "$EPOCH_MS" && "$EPOCH_MS" =~ ^[0-9]+$ ]]; then
                EPOCH_SEC=$((EPOCH_MS / 1000))
                BUILD_TIME=$(date -d "@$EPOCH_SEC" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || date -r "$EPOCH_SEC" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || echo "Unknown")
                echo "BUILD_UI_URL=$BUILD_UI_URL" >> $GITHUB_ENV
                echo "BUILD_TIME=$BUILD_TIME" >> $GITHUB_ENV
              fi
            fi

            echo "✅ Build info published successfully for bookverse-core"
            echo "🔗 Build URL: ${BUILD_UI_URL:-'URL extraction failed'}"
          else
            echo "❌ Failed to publish build info for bookverse-core"
            exit 1
          fi

      - name: "[Evidence] Attach build evidence using shared library"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
          EVIDENCE_KEY_ALIAS: ${{ vars.EVIDENCE_KEY_ALIAS }}
        run: |
          echo "📋 Using shared evidence library for bookverse-core build"
          echo "🔐 Evidence will be cryptographically signed for compliance verification"

          source ../bookverse-devops/scripts/evidence-lib.sh

          export PACKAGE_NAME="bookverse-core"
          export PACKAGE_VERSION="$PACKAGE_VERSION"
          export SERVICE_NAME="core"
          export APPLICATION_KEY="bookverse-core"
          export ATTACH_TO_BUILD="true"
          export ATTACH_TO_PACKAGE="false"

          echo "🏗️ Attaching SonarQube evidence to build"
          attach_build_sonar_evidence

          echo "📋 Attaching FOSSA license evidence to build"
          attach_build_fossa_evidence

          echo "✅ Evidence attached to build using shared library"

  build-bookverse-devops:
    name: "Build: bookverse-devops"
    needs: [analyze-commit]
    if: needs.analyze-commit.outputs.devops_changed == 'true' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: libraries/bookverse-devops
    permissions:
      contents: read
      id-token: write
    outputs:
      build_name: ${{ steps.set-build-info.outputs.build_name }}
      build_number: ${{ steps.set-build-info.outputs.build_number }}
      package_version: ${{ steps.set-version.outputs.package_version }}

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Info] Build Information"
        run: |
          echo "🛠️ Building bookverse-devops CI/CD library"
          echo "🔄 Event: ${{ github.event_name }}"
          echo "👤 Triggered by: ${{ github.actor }}"
          echo "🕐 Timestamp: $(date -u)"

      - name: "[Setup] Build Info"
        id: set-build-info
        run: |
          BUILD_NAME="bookverse-devops_${{ github.workflow }}_${{ github.job }}"
          BUILD_NUMBER="${{ github.run_number }}-${{ github.run_attempt }}"
          echo "build_name=$BUILD_NAME" >> $GITHUB_OUTPUT
          echo "build_number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          echo "BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "🏷️ Build: $BUILD_NAME"

      - name: "[Setup] Install and Configure JFrog CLI"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
          JFROG_CLI_BUILD_NAME: ${{ env.BUILD_NAME }}
          JFROG_CLI_BUILD_NUMBER: ${{ env.BUILD_NUMBER }}
          JFROG_CLI_BUILD_PROJECT: ${{ vars.PROJECT_KEY }}
        with:
          version: latest
          oidc-provider-name: bookverse-infra-github
          oidc-audience: ${{ vars.JFROG_URL }}
          disable-job-summary: false
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false

      - name: "[Setup] Verify JFrog CLI Configuration"
        run: |
          echo "🔧 Verifying JFrog CLI configuration"
          echo "✅ JFrog CLI installed and configured with OIDC authentication"
          echo "🏷️ Build: $BUILD_NAME"

          jf rt ping

      - name: "[Setup] Python"
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: "[Build] Install dependencies"
        run: |
          python -m pip install --upgrade "pip<25"
          pip install requests urllib3 pyyaml
          echo "✅ Installed bookverse-devops dependencies"

      - name: "[Test] Validate scripts and workflows"
        run: |
          set -euo pipefail

          python scripts/semver_versioning.py --help
          echo "✅ semver_versioning.py script validated"

          chmod +x scripts/determine-semver.sh
          ./scripts/determine-semver.sh --help || echo "Script help test completed"
          echo "✅ determine-semver.sh script validated"

          python -c "
          import yaml
          import os

          yaml_files = []
          for root, dirs, files in os.walk('.'):
              for file in files:
                  if file.endswith('.yml') or file.endswith('.yaml'):
                      yaml_files.append(os.path.join(root, file))

          for file in yaml_files:
              try:
                  with open(file, 'r') as f:
                      yaml.safe_load(f)
                  print(f'✅ {file} is valid YAML')
              except Exception as e:
                  print(f'❌ {file} has invalid YAML: {e}')
                  exit(1)

          print('✅ All YAML files validated')
          "

      - name: "[Build] Package DevOps artifacts"
        id: set-version
        run: |
          PACKAGE_VERSION="1.0.${{ github.run_number }}"
          echo "package_version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT
          echo "PACKAGE_VERSION=$PACKAGE_VERSION" >> $GITHUB_ENV

          tar -czf "bookverse-devops-${PACKAGE_VERSION}.tar.gz" scripts/ evidence/ templates/ *.md

          cat > version-manifest.json << EOF
          {
            "name": "bookverse-devops",
            "version": "$PACKAGE_VERSION",
            "build_number": "$BUILD_NUMBER",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "contents": {
              "scripts": "$(ls scripts/ | wc -l) files",
              "evidence_templates": "$(find evidence/ -name '*.template' | wc -l) templates",
              "workflow_templates": "$(find templates/ -name '*.yml' -o -name '*.yaml' | wc -l) workflows"
            }
          }
          EOF

          echo "✅ Packaged bookverse-devops v$PACKAGE_VERSION"

      - name: "[Artifacts] Upload to JFrog"
        run: |
          set -euo pipefail

          # DevOps artifacts created locally - repository not available
          echo "📦 DevOps artifacts created locally (upload disabled - repository not available)"
          echo "✅ DevOps artifacts prepared locally (build info will contain git/environment data)"

      - name: "[Build] Publish Build Info"
        run: |
          set -euo pipefail

          echo "📋 Publishing build-info for bookverse-devops library"
          echo "🏗️ Build: $BUILD_NAME/$BUILD_NUMBER"
          echo "📦 Contains: DevOps scripts + templates + validation evidence"

          jf rt bag --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          jf rt bce --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"
          if BUILD_PUBLISH_RESULT=$(jf rt bp --project "${{ vars.PROJECT_KEY }}" "$BUILD_NAME" "$BUILD_NUMBER"); then
            echo "BUILD_INFO_PUBLISH_STATUS=SUCCESS" >> $GITHUB_ENV
            BUILD_UI_URL=$(echo "$BUILD_PUBLISH_RESULT" | grep -o 'https://[^[:space:]]*builds/[^[:space:]]*' | head -1 || echo "")

            if [[ -n "$BUILD_UI_URL" ]]; then
              EPOCH_MS=$(echo "$BUILD_UI_URL" | sed -n 's|.*/builds/[^/]*/[^/]*/\([0-9]*\)/published.*|\1|p')

              if [[ -n "$EPOCH_MS" && "$EPOCH_MS" =~ ^[0-9]+$ ]]; then
                EPOCH_SEC=$((EPOCH_MS / 1000))
                BUILD_TIME=$(date -d "@$EPOCH_SEC" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || date -r "$EPOCH_SEC" '+%Y-%m-%d %H:%M:%S UTC' 2>/dev/null || echo "Unknown")
                echo "BUILD_UI_URL=$BUILD_UI_URL" >> $GITHUB_ENV
                echo "BUILD_TIME=$BUILD_TIME" >> $GITHUB_ENV
              fi
            fi

            echo "✅ Build info published successfully for bookverse-devops"
            echo "🔗 Build URL: ${BUILD_UI_URL:-'URL extraction failed'}"
          else
            echo "❌ Failed to publish build info for bookverse-devops"
            exit 1
          fi

      - name: "[Evidence] Attach build evidence using shared library"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
          EVIDENCE_KEY_ALIAS: ${{ vars.EVIDENCE_KEY_ALIAS }}
        run: |
          echo "📋 Using shared evidence library for bookverse-devops build"
          echo "🔐 Evidence will be cryptographically signed for compliance verification"

          source scripts/evidence-lib.sh

          export PACKAGE_NAME="bookverse-devops"
          export PACKAGE_VERSION="$PACKAGE_VERSION"
          export SERVICE_NAME="devops"
          export APPLICATION_KEY="bookverse-devops"
          export ATTACH_TO_BUILD="true"
          export ATTACH_TO_PACKAGE="false"

          echo "🏗️ Attaching SonarQube evidence to build"
          attach_build_sonar_evidence

          echo "📋 Attaching FOSSA license evidence to build"
          attach_build_fossa_evidence

          echo "✅ Evidence attached to build using shared library"

  create-promote:
    name: "Create Application Version & Promote (Conditional)"
    needs: [analyze-commit, build-bookverse-core, build-bookverse-devops]
    if: needs.analyze-commit.outputs.create_app_version == 'true' && (needs.build-bookverse-core.result == 'success' || needs.build-bookverse-core.result == 'skipped') && (needs.build-bookverse-devops.result == 'success' || needs.build-bookverse-devops.result == 'skipped')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write

    env:
      BUILD_NAME: "bookverse-infra_CI_create-promote"
      BUILD_NUMBER: ${{ github.run_number }}-${{ github.run_attempt }}
      SERVICE_NAME: "infra"
      APPLICATION_KEY: "bookverse-infra"
      EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
      EVIDENCE_KEY_ALIAS: ${{ vars.EVIDENCE_KEY_ALIAS }}
      JFROG_URL: ${{ vars.JFROG_URL }}
      JF_URL: ${{ vars.JFROG_URL }}
      PROJECT_KEY: ${{ vars.PROJECT_KEY }}
      STAGES_STR: "DEV QA STAGING PROD"
      FINAL_STAGE: "PROD"
      ALLOW_RELEASE: "true"

    outputs:
      app_version: ${{ steps.create-version.outputs.app_version }}

    steps:
      - name: "[Setup] Checkout"
        uses: actions/checkout@v4

      - name: "[Setup] Checkout bookverse-infra for shared scripts"
        uses: actions/checkout@v4
        with:
          repository: yonatanp-jfrog/bookverse-infra
          path: bookverse-infra

      - name: "[Setup] JFrog CLI"
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        id: jfrog-cli-auth
        env:
          JF_URL: ${{ vars.JFROG_URL }}
          JF_PROJECT: ${{ vars.PROJECT_KEY }}
        with:
          version: latest
          oidc-provider-name: bookverse-infra-github
          oidc-audience: ${{ vars.JFROG_URL }}
          disable-job-summary: true
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false

      - name: "[Auth] OIDC Token Ready"
        id: auth-ready
        run: |
          echo "🔐 OIDC authentication already configured via JFrog CLI setup"
          echo "✅ Authentication ready for AppTrust API calls"

      - name: "[Setup] Install Python dependencies"
        run: |
          pip install --user PyYAML setuptools wheel
          echo "✅ Python dependencies installed"

      - name: "[Setup] Generate Application Version"
        id: generate-version
        run: |
          APP_VERSION=$(python -c "
          import requests
          import json
          from datetime import datetime

          timestamp = datetime.now().strftime('%Y.%m.%d.%H%M')
          version = f'1.0.{timestamp}'
          print(version)
          ")

          echo "🏷️ Generated Application Version: $APP_VERSION"
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "app_version=$APP_VERSION" >> $GITHUB_OUTPUT

      - name: "[Create] Application Version"
        run: |
          echo "🚀 Creating AppTrust application version: ${{ env.APP_VERSION }}"
          echo "📦 Binding artifacts from dual infrastructure builds:"
          echo "   - bookverse-core: ${{ needs.build-bookverse-core.outputs.build_name }}/${{ needs.build-bookverse-core.outputs.build_number }}"
          echo "   - bookverse-devops: ${{ needs.build-bookverse-devops.outputs.build_name }}/${{ needs.build-bookverse-devops.outputs.build_number }}"
          echo "🔗 This creates an immutable link between application version and all published artifacts"

          export JF_OIDC_TOKEN="${{ steps.jfrog-cli-auth.outputs.oidc-token }}"

          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "❌ Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            echo "Debug - JFrog CLI outputs:"
            echo "  oidc-token: '${{ steps.jfrog-cli-auth.outputs.oidc-token }}'"
            exit 1
          fi
          echo "✅ Using JF_OIDC_TOKEN for AppTrust API authentication"

          BASE="${{ vars.JFROG_URL }}/apptrust/api/v1"
          APP_KEY="$APPLICATION_KEY"
          APP_VERSION="${{ env.APP_VERSION }}"

          echo "🔍 Preflight: ensuring application '$APP_KEY' exists"
          APP_GET_CODE=$(curl -s -o /dev/null -w '%{http_code}' "$BASE/applications/$APP_KEY" \
            -H "Authorization: Bearer $JF_OIDC_TOKEN" -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" -H "Accept: application/json")
          if [[ "$APP_GET_CODE" == "404" ]]; then
            echo "🆕 Application not found; creating it"
            CREATE_APP_BODY=$(jq -n --arg name "BookVerse Infrastructure" --arg key "$APP_KEY" --arg proj "${{ vars.PROJECT_KEY }}" '{application_name:$name, application_key:$key, project_key:$proj}')
            APP_CREATE_CODE=$(curl -s -o /tmp/app_create.json -w '%{http_code}' -X POST "$BASE/applications/" \
              -H "Authorization: Bearer $JF_OIDC_TOKEN" -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" -H "Content-Type: application/json" -H "Accept: application/json" \
              -d "$CREATE_APP_BODY")
            echo "📨 Create Application Response:"; cat /tmp/app_create.json || true
            if [[ "$APP_CREATE_CODE" -lt 200 || "$APP_CREATE_CODE" -ge 300 ]]; then
              echo "❌ Failed to create application (HTTP $APP_CREATE_CODE)"; exit 1
            fi
            echo "✅ Application '$APP_KEY' created successfully"
          else
            echo "✅ Application '$APP_KEY' already exists"
          fi

          TAG_OPTIONS=(release hotfix feature bugfix enhancement security performance refactor)
          TAG_INDEX=$((${GITHUB_RUN_NUMBER:-0} % ${#TAG_OPTIONS[@]}))
          APP_TAG="${TAG_OPTIONS[$TAG_INDEX]}"

          SOURCES='[]'

          if [[ "${{ needs.build-bookverse-core.result }}" == "success" ]]; then
            CORE_SOURCE='{"name":"${{ needs.build-bookverse-core.outputs.build_name }}","number":"${{ needs.build-bookverse-core.outputs.build_number }}","repository_key":"${{ vars.PROJECT_KEY }}-build-info","include_dependencies":false}'
            SOURCES=$(echo "$SOURCES" | jq ". + [$CORE_SOURCE]")
          fi

          if [[ "${{ needs.build-bookverse-devops.result }}" == "success" ]]; then
            DEVOPS_SOURCE='{"name":"${{ needs.build-bookverse-devops.outputs.build_name }}","number":"${{ needs.build-bookverse-devops.outputs.build_number }}","repository_key":"${{ vars.PROJECT_KEY }}-build-info","include_dependencies":false}'
            SOURCES=$(echo "$SOURCES" | jq ". + [$DEVOPS_SOURCE]")
          fi

          SOURCES_JSON=$(echo "$SOURCES" | jq -c .)
          APP_VERSION_PAYLOAD='{"version":"'$APP_VERSION'","tag":"'$APP_TAG'","sources":{"builds":'$SOURCES_JSON'}}'

          echo "📋 Creating application version with payload:"
          echo "$APP_VERSION_PAYLOAD" | jq . || echo "$APP_VERSION_PAYLOAD"

          RESP_BODY=$(mktemp)
          HTTP_STATUS=$(curl -sS -L -o "$RESP_BODY" -w "%{http_code}" -X POST \
            "$BASE/applications/$APP_KEY/versions?async=false" \
            -H "Authorization: Bearer $JF_OIDC_TOKEN" \
            -H "Content-Type: application/json" \
            -H "X-JFrog-Project: ${{ vars.PROJECT_KEY }}" \
            -d "$APP_VERSION_PAYLOAD" \
            --fail-with-body)

          echo "🔢 HTTP Status: $HTTP_STATUS"
          echo "📨 Response Body:"
          cat "$RESP_BODY" | jq . 2>/dev/null || cat "$RESP_BODY"
          echo ""

          if [[ "$HTTP_STATUS" -ge 200 && "$HTTP_STATUS" -lt 300 ]]; then
            echo "✅ Created application version $APP_VERSION"
          else
            echo "⚠️ Application version creation returned HTTP $HTTP_STATUS"
            if [[ "$HTTP_STATUS" == "409" ]]; then
              echo "📝 Version $APP_VERSION already exists, continuing with promotion..."
            else
              echo "❌ Failed to create application version" >&2
              rm -f "$RESP_BODY"
              exit 1
            fi
          fi
          rm -f "$RESP_BODY"

          echo "🔍 Validating application version creation..."
          CONTENT_FILE=$(mktemp)
          CONTENT_STATUS=$(curl -sS -L -o "$CONTENT_FILE" -w "%{http_code}" \
            "$BASE/applications/$APP_KEY/versions/$APP_VERSION/content" \
            -H "Authorization: Bearer $JF_OIDC_TOKEN" \
            -H "Accept: application/json")

          if [[ "$CONTENT_STATUS" != "200" ]]; then
            echo "❌ Version content endpoint returned HTTP $CONTENT_STATUS for $APP_KEY@$APP_VERSION" >&2
            echo "📨 Response Body:"; cat "$CONTENT_FILE" || true; echo
            rm -f "$CONTENT_FILE"
            exit 1
          fi
          VERSION_STATE=$(jq -r '.status // empty' "$CONTENT_FILE" 2>/dev/null || echo "")
          echo "📨 Version Content:"; cat "$CONTENT_FILE" || true; echo
          rm -f "$CONTENT_FILE"
          if [[ "$VERSION_STATE" != "COMPLETED" ]]; then
            echo "❌ Application version not in COMPLETED state (status='$VERSION_STATE') for $APP_KEY@$APP_VERSION" >&2
            exit 1
          fi
          echo "✅ Application version created and validated (COMPLETED): $APP_KEY@$APP_VERSION"

      - name: "[Evidence] Application Version Evidence"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
          EVIDENCE_KEY_ALIAS: ${{ vars.EVIDENCE_KEY_ALIAS }}
        run: |
          echo "📋 Generating evidence for application version (UNASSIGNED stage)"

          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh

          attach_application_unassigned_evidence

          echo "✅ Application version evidence attached via shared library: slsa-provenance, jira-release"

      - name: "[Promote & Evidence] DEV Stage"
        run: |
          echo "🧪 Promoting application to DEV stage with automated evidence collection"
          echo "📋 Application Version: ${{ env.APP_VERSION }}"
          echo "🎯 Target Stage: DEV (development environment for feature testing)"
          echo "🛡️ Evidence Type: Smoke tests and basic health validation"

          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "❌ Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          echo "✅ Using JF_OIDC_TOKEN for DEV promotion"

          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment

          if advance_one_step; then
            echo "✅ Successfully promoted to DEV"
          else
            echo "❌ Failed to promote to DEV"
            exit 1
          fi

          attach_application_dev_evidence
          echo "✅ DEV stage evidence attached via shared library: smoke-tests"

      - name: "[Promote & Evidence] QA Stage"
        run: |
          echo "🔍 Promoting to QA stage and generating evidence"

          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "❌ Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          echo "✅ Using JF_OIDC_TOKEN for QA promotion"

          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment

          if advance_one_step; then
            echo "✅ Successfully promoted to QA"
          else
            echo "❌ Failed to promote to QA"
            exit 1
          fi

          attach_application_qa_evidence
          echo "✅ QA stage evidence attached via shared library: dast-scan, api-tests"

      - name: "[Promote & Evidence] STAGING Stage"
        run: |
          echo "🏗️ Promoting to STAGING stage and generating evidence"

          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "❌ Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          echo "✅ Using JF_OIDC_TOKEN for STAGING promotion"

          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment

          if advance_one_step; then
            echo "✅ Successfully promoted to STAGING"
          else
            echo "❌ Failed to promote to STAGING"
            exit 1
          fi

          attach_application_staging_evidence
          echo "✅ STAGING stage evidence attached via shared library: iac-scan, pentest, change-approval"

      - name: "[Promote & Evidence] PROD Stage"
        run: |
          echo "🚀 Promoting to PROD stage and generating evidence"

          if [[ -z "${JF_OIDC_TOKEN:-}" ]]; then
            echo "❌ Missing JF_OIDC_TOKEN. Ensure OIDC exchange step succeeded." >&2
            exit 1
          fi
          echo "✅ Using JF_OIDC_TOKEN for PROD promotion"

          source bookverse-infra/libraries/bookverse-devops/scripts/evidence-lib.sh
          setup_promotion_environment

          if advance_one_step; then
            echo "✅ Successfully promoted to PROD"
          else
            echo "❌ Failed to promote to PROD"
            exit 1
          fi

          attach_application_prod_evidence
          echo "✅ PROD stage evidence attached via shared library: deployment-verification"

      - name: "[Summary] Infrastructure Deployment Complete"
        run: |
          echo "## 🚀 Infrastructure Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📋 Application Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Application**: \`bookverse-infra\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Version**: \`${{ env.APP_VERSION }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Trigger**: ${{ needs.analyze-commit.outputs.decision_reason }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Final Stage**: PROD ✅" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📦 Package Builds" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ needs.build-bookverse-core.result }}" == "success" ]]; then
            echo "- **bookverse-core**: v${{ needs.build-bookverse-core.outputs.package_version }} (Coverage: ${{ needs.build-bookverse-core.outputs.coverage_percent }}%)" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **bookverse-core**: Skipped (no changes)" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ needs.build-bookverse-devops.result }}" == "success" ]]; then
            echo "- **bookverse-devops**: v${{ needs.build-bookverse-devops.outputs.package_version }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- **bookverse-devops**: Skipped (no changes)" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🛡️ Evidence & Promotion Trail" >> $GITHUB_STEP_SUMMARY
          echo "- **UNASSIGNED**: Evidence attached (SLSA provenance, Jira release)" >> $GITHUB_STEP_SUMMARY
          echo "- **DEV**: Promoted ✅ + Evidence (smoke tests)" >> $GITHUB_STEP_SUMMARY
          echo "- **QA**: Promoted ✅ + Evidence (DAST scan, API tests)" >> $GITHUB_STEP_SUMMARY
          echo "- **STAGING**: Promoted ✅ + Evidence (IaC scan, pentest, change approval)" >> $GITHUB_STEP_SUMMARY
          echo "- **PROD**: Promoted ✅ + Evidence (deployment verification)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ✅ Deployment Status" >> $GITHUB_STEP_SUMMARY
          echo "- Infrastructure libraries available in JFrog Artifactory" >> $GITHUB_STEP_SUMMARY
          echo "- Services can consume bookverse-core and bookverse-devops libraries" >> $GITHUB_STEP_SUMMARY
          echo "- Full evidence trail collected across all lifecycle stages" >> $GITHUB_STEP_SUMMARY
          echo "- Application successfully deployed to PROD" >> $GITHUB_STEP_SUMMARY